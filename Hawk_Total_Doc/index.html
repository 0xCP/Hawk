<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>17.Hawk_Total_Doc - Hawk doc</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "17.Hawk_Total_Doc";
    var mkdocs_page_input_path = "Hawk_Total_Doc.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Hawk doc</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="./">1.Hawk</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">2.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">3.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">4.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">5.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">6.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">7.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">8.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">9.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">10.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">11.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">12.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">13.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">14.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">15.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="./">16.Hawk_Total_Doc</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">17.Hawk_Total_Doc</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#hawk">欢迎使用Hawk</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#11">1.1.介绍</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_1">快速教程</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1">1.界面和交互</a></li>
        
            <li><a class="toctree-l3" href="#2">2.网页采集器</a></li>
        
            <li><a class="toctree-l3" href="#3">3.数据清洗</a></li>
        
            <li><a class="toctree-l3" href="#4">4.一些忠告</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#hawk_1">Hawk工程</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_1">1.自动保存</a></li>
        
            <li><a class="toctree-l3" href="#2hawk">2.Hawk工程介绍</a></li>
        
            <li><a class="toctree-l3" href="#3_1">3.全局配置系统</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_2">主要组件介绍</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1hawk">1.Hawk的关键概念</a></li>
        
            <li><a class="toctree-l3" href="#2hawk_1">2.Hawk任务市场</a></li>
        
            <li><a class="toctree-l3" href="#3_2">3.调试系统</a></li>
        
            <li><a class="toctree-l3" href="#4_1">4.日志功能</a></li>
        
            <li><a class="toctree-l3" href="#5">5.多国语言</a></li>
        
            <li><a class="toctree-l3" href="#6">6.帮助文档系统</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_4">数据表和数据库连接</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_2">1.数据表</a></li>
        
            <li><a class="toctree-l3" href="#2_1">2.数据库连接器</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_6">网页采集器</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_3">1.主要配置介绍</a></li>
        
            <li><a class="toctree-l3" href="#2_2">2.抓取网页数据</a></li>
        
            <li><a class="toctree-l3" href="#3_3">3.手气不错</a></li>
        
            <li><a class="toctree-l3" href="#4_2">4.动态嗅探</a></li>
        
            <li><a class="toctree-l3" href="#5_1">5.超级模式</a></li>
        
            <li><a class="toctree-l3" href="#6_1">6.超级模式的原理</a></li>
        
            <li><a class="toctree-l3" href="#7">7.设置共享请求参数的采集器名称</a></li>
        
            <li><a class="toctree-l3" href="#8xpathcss">8.附录：XPath和CSS写法</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_7">数据清洗</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_4">1.参数说明</a></li>
        
            <li><a class="toctree-l3" href="#2_3">2.几种模块的介绍</a></li>
        
            <li><a class="toctree-l3" href="#3_4">3.运行模式</a></li>
        
            <li><a class="toctree-l3" href="#4_3">4.线程管理</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_8">转换器</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#baidulocation">搜索位置(BaiduLocation)</a></li>
        
            <li><a class="toctree-l3" href="#ipgetiplocation">获取IP的坐标(GetIPLocation)</a></li>
        
            <li><a class="toctree-l3" href="#getroute">获取路径信息(GetRoute)</a></li>
        
            <li><a class="toctree-l3" href="#nearbysearch">检索附近(NearbySearch)</a></li>
        
            <li><a class="toctree-l3" href="#nlptf">自然语言处理(NlpTF)</a></li>
        
            <li><a class="toctree-l3" href="#transtf">语言翻译转换(TransTF)</a></li>
        
            <li><a class="toctree-l3" href="#addnewtf">添加新列(AddNewTF)</a></li>
        
            <li><a class="toctree-l3" href="#autoindextf">自增键生成(AutoIndexTF)</a></li>
        
            <li><a class="toctree-l3" href="#renametf">列名修改器(RenameTF)</a></li>
        
            <li><a class="toctree-l3" href="#deletetf">删除该列(DeleteTF)</a></li>
        
            <li><a class="toctree-l3" href="#joindbtf">数据库匹配(JoinDBTF)</a></li>
        
            <li><a class="toctree-l3" href="#repeattf">重复当前值(RepeatTF)</a></li>
        
            <li><a class="toctree-l3" href="#responsetf">获取请求响应(ResponseTF)</a></li>
        
            <li><a class="toctree-l3" href="#suppliertf">重试补数据(SupplierTF)</a></li>
        
            <li><a class="toctree-l3" href="#time2strtf">时间转字符串(Time2StrTF)</a></li>
        
            <li><a class="toctree-l3" href="#urlurltf">URL字符转义(UrlTF)</a></li>
        
            <li><a class="toctree-l3" href="#htmlhtmltf">HTML字符转义(HtmlTF)</a></li>
        
            <li><a class="toctree-l3" href="#regexsplittf">正则分割(RegexSplitTF)</a></li>
        
            <li><a class="toctree-l3" href="#mergetf">合并多列(MergeTF)</a></li>
        
            <li><a class="toctree-l3" href="#pythonpythontf">Python转换器(PythonTF)</a></li>
        
            <li><a class="toctree-l3" href="#rereplacetf">正则替换(ReReplaceTF)</a></li>
        
            <li><a class="toctree-l3" href="#regextf">正则转换器(RegexTF)</a></li>
        
            <li><a class="toctree-l3" href="#numbertf">提取数字(NumberTF)</a></li>
        
            <li><a class="toctree-l3" href="#strextracttf">字符首尾抽取(StrExtractTF)</a></li>
        
            <li><a class="toctree-l3" href="#tolisttf">启动并行(ToListTF)</a></li>
        
            <li><a class="toctree-l3" href="#trimtf">清除空白符(TrimTF)</a></li>
        
            <li><a class="toctree-l3" href="#fileexistft">路径是否存在(FileExistFT)</a></li>
        
            <li><a class="toctree-l3" href="#mergerepeattf">重复项合并(MergeRepeatTF)</a></li>
        
            <li><a class="toctree-l3" href="#dicttf">矩阵转置(DictTF)</a></li>
        
            <li><a class="toctree-l3" href="#-etltf">子任务-转换(EtlTF)</a></li>
        
            <li><a class="toctree-l3" href="#xpathxpathtf">XPath转换器(XPathTF)</a></li>
        
            <li><a class="toctree-l3" href="#xpathtf2">门类枚举(XPathTF2)</a></li>
        
            <li><a class="toctree-l3" href="#splittf">字符串分割(SplitTF)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_31">常用</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#crawlertf">从爬虫转换(CrawlerTF)</a></li>
        
            <li><a class="toctree-l3" href="#splitpagetf">分页(SplitPageTF)</a></li>
        
            <li><a class="toctree-l3" href="#jsonjsontf">转换为Json(JsonTF)</a></li>
        
            <li><a class="toctree-l3" href="#delaytf">延时(DelayTF)</a></li>
        
            <li><a class="toctree-l3" href="#-etlex">子任务-执行(EtlEX)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_35">过滤器</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#nullft">空对象过滤器(NullFT)</a></li>
        
            <li><a class="toctree-l3" href="#rangeft">数值范围过滤器(RangeFT)</a></li>
        
            <li><a class="toctree-l3" href="#regexft">正则筛选器(RegexFT)</a></li>
        
            <li><a class="toctree-l3" href="#repeatft">删除重复项(RepeatFT)</a></li>
        
            <li><a class="toctree-l3" href="#numrangeft">数量范围选择(NumRangeFT)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_36">执行器</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#dbex">写入数据库(DbEX)</a></li>
        
            <li><a class="toctree-l3" href="#savefileex">保存超链接文件(SaveFileEX)</a></li>
        
            <li><a class="toctree-l3" href="#tableex">写入数据表(TableEX)</a></li>
        
            <li><a class="toctree-l3" href="#writefiletexttf">写入文件文本(WriteFileTextTF)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_37">生成器</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#daterangege">生成区间时间(DateRangeGE)</a></li>
        
            <li><a class="toctree-l3" href="#readfiletextge">读取文件文本(ReadFileTextGE)</a></li>
        
            <li><a class="toctree-l3" href="#readfilege">读取文件数据(ReadFileGe)</a></li>
        
            <li><a class="toctree-l3" href="#folderge">获取文件夹文件(FolderGE)</a></li>
        
            <li><a class="toctree-l3" href="#dbge">从数据库生成(DbGE)</a></li>
        
            <li><a class="toctree-l3" href="#randomge">生成随机数(RandomGE)</a></li>
        
            <li><a class="toctree-l3" href="#rangege">生成区间数(RangeGE)</a></li>
        
            <li><a class="toctree-l3" href="#tablege">从数据表生成(TableGE)</a></li>
        
            <li><a class="toctree-l3" href="#textge">从文本生成(TextGE)</a></li>
        
            <li><a class="toctree-l3" href="#bfsge">请求队列(BfsGE)</a></li>
        
            <li><a class="toctree-l3" href="#-etlge">子任务-生成(EtlGE)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_38">子任务引擎</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_5">1.基本概念</a></li>
        
            <li><a class="toctree-l3" href="#2_4">2.参数设置</a></li>
        
            <li><a class="toctree-l3" href="#3_5">3.注意事项</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_39">动态页面抓取专题</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_6">1.什么是动态页面？</a></li>
        
            <li><a class="toctree-l3" href="#2_5">2.获取真实数据请求</a></li>
        
            <li><a class="toctree-l3" href="#3_6">3.请求构造</a></li>
        
            <li><a class="toctree-l3" href="#4_4">4.数据后处理</a></li>
        
            <li><a class="toctree-l3" href="#5_2">5.案例.</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_40">增量/自动化/定时抓取专题</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_8">1.增量抓取</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_41">编译和扩展开发</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_9">1.编译</a></li>
        
            <li><a class="toctree-l3" href="#2_8">2.代码结构</a></li>
        
            <li><a class="toctree-l3" href="#3_8">3.实现新的连接器</a></li>
        
            <li><a class="toctree-l3" href="#4_5">4.实现新的子模块组件</a></li>
        
            <li><a class="toctree-l3" href="#5_3">5.备注</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#_42">常见问题</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#1_10">1.网页采集器</a></li>
        
            <li><a class="toctree-l3" href="#2_9">2.数据清洗</a></li>
        
            <li><a class="toctree-l3" href="#3_9">3.编译与运行问题</a></li>
        
            <li><a class="toctree-l3" href="#4_6">4.宏观问题</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hawk doc</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>17.Hawk_Total_Doc</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="hawk">欢迎使用Hawk</h1>
<p>Advanced Crawler  ETL tool written in C#/WPF</p>
<hr />
<p>欢迎使用Hawk! HAWK无需编程，可见即所得的图形化数据采集和清洗工具，依据GPL协议开源。</p>
<p>项目主页： https://ferventdesert.github.io/Hawk/</p>
<h2 id="11">1.1.介绍</h2>
<p>Hawk的含义为“鹰”，能够高效，准确地捕杀猎物。它的思想来源于Lisp语言，功能模仿了Linux工具awk。</p>
<p>特点如下：</p>
<ul>
<li>智能分析网页内容，无需编程</li>
<li>所见即所得，可视化拖拽，快地实现转换和过滤等数据清洗操作</li>
<li>能从各类数据库和文件实现导入导出</li>
<li>任务可以被保存和复用</li>
<li>其最适合的领域是爬虫和数据清洗，但其威力远超于此。</li>
</ul>
<p>HAWK使用C# 编写，其前端界面使用WPF开发，因此只能运行于windows平台，但提供命令行入口供自动化部署。
以下介绍全部基于最新的Hawk3，请使用老版本的同学尽快通过下面的地址升级最新版。</p>
<p><img alt="2.gif-3330.9kB" src="http://static.zybuluo.com/buptzym/10kykg6qhqvsabbq8yj32pt0/2.gif" /></p>
<p>以获取大众点评的所有北京美食为例，使用本软件可在10分钟内完成配置，在1小时之内<strong>自动并行抓取</strong>全部内容，并能监视任务工作情况。而手工编写代码，即使是使用python，一个熟练的程序员也可能需要一天以上：</p>
<p><img alt="1.gif-1001.8kB" src="http://static.zybuluo.com/buptzym/qkl0vavjn6cj007qfk2k3gqg/1.gif" /></p>
<h1 id="_1">快速教程</h1>
<p>本文给不想看详细教程的同学使用，仔细阅读，可以让你战斗力爆棚：</p>
<h2 id="1">1.界面和交互</h2>
<ol>
<li>在【模块管理】页面，左侧是【任务管理】，双击图标即可新建和加载已有任务
点击菜单【文件】可加载，保存任务，任务为xml文件。
右侧是【数据管理】，空白处右键可新建连接，连接名上右键可配置，支持本地文件(xls,txt,json)，数据库(mongodb,sqlite)
数据库需要连接后才能使用，可勾选【自动连接】.</li>
<li>软件右下角对应的是【系统状态视图】，左右侧分别是已加载的任务和数据集。
左键查看，右键配置，空白处右键批量管理。 下面的图标可用于删除，拷贝，保存等功能，把任务或数据集拖到图标上试试！</li>
<li>【网页采集器】用于配置单个网页的抓取规则，【数据清洗】用于打造清洗流程，并调用前者。 复杂任务会创建多个清洗并互相调用。</li>
</ol>
<h2 id="2">2.网页采集器</h2>
<ol>
<li>上方输入网址，点击刷新，选择工作模式(List列表页，生成多条数据；One详情页，单条数据, NoTransform是原始内容，不做转换)</li>
<li>网页可在源码模式和浏览器模式下切换，后者仅供参考，不能动态执行js</li>
<li>点击【手气不错】进入全自动模式，在弹出的结果下选择所需数据，可配置其名称和XPath，点击【刷新】更新</li>
<li>也可以手工搜索字符，可快速定位元素和XPath，输入名称后手工添加属性。</li>
<li>点击【提取测试】，可预览检查配置结果。</li>
</ol>
<h3 id="2121">2.1.2.1</h3>
<ol>
<li>右侧【属性配置器】面板，点击【请求详情】，可修改网页编码，代理，cookie和请求方式等</li>
<li>若是动态页面(ajax)，填入搜索字符，点击【自动嗅探】，在弹出的浏览器中翻到对应的关键字，Hawk就能自动捕捉真实请求</li>
<li>超级模式下，Hawk会将源码中的js,html,json都转成html，更通用但性能较差</li>
<li>填写【共享源】，本采集器同步共享源的【请求详情】，避免重复设置cookie代理等。</li>
<li>详情页(One模式)也可以手气不错(Hawk3新功能)，搜索所需字段，不需要添加到属性列表，点击【手气不错】试试！</li>
<li>网页地址也可以是本地文件路径，如D:\target.html, 用其他方法保存网页后，通过Hawk做数据清洗</li>
</ol>
<h2 id="3">3.数据清洗</h2>
<ol>
<li>左侧是所有模块列表，分为生成，转换，过滤和执行四种类型，可通过名称和拼音首字母快速检索。顺序组合可构成复杂任务。
右侧是数据预览，可将选中的模块拖入到右侧对应列上。 双击每个列上面的模块对其配置。将鼠标放在字段上可查看使用介绍。
预览时，处理是串行的，数据不会被写入，有缓存，调试所见即所得。 只有在执行模式下才会并行快速执行。
执行器可看做带有副作用(如写入文件)的转换器，</li>
<li>生成器通常位于任务开头，可从文本，文件，数据库读取数据。
多个生成器结果有四种方式组合：Merge:横向合并，Append:纵向拼接， Cross:笛卡尔集 , Mix:依次交叉，如121212..</li>
<li>一些转换器也有类似网页采集器的工作模式，后者本质上就是个高级的转换器。</li>
<li>下方菜单栏可点击刷新，前后单步，可通过采样量来修改预览的数据量。配置完毕无误后，右侧面板点击【执行】即可。</li>
</ol>
<h3 id="31">3.1.高级功能和提醒</h3>
<ol>
<li>配置输入列可下拉选择，也可手工输入文本。列名不要为纯数字，否则无法正常显示。</li>
<li>很多问题来自于模块顺序不对，任何步骤错误，会导致连锁的问题，因此有必要使用单步调试，在调试到某步时，拖入的模块会插入到所在位置。</li>
<li>Python转换器：最后一行必须是可求值的表达式。例如有两列a,b,转换器输出列为c，表达式为a+b，则c列内容就是a+b。但表达式不能写c=a+b</li>
<li>Python是强类型语言，输入的数据可能是字符串或数字，因此必要时需要做类型转换</li>
<li>通过填写库路径，可让转换器调用第三方模块。但这一功能支持不好。</li>
<li>一般在List模式的转换器之前拖入【并行】，可大大提升并行速度。</li>
<li>可在任务的各个位置拖入多个执行器(如【写入数据表】)，它保存的是当前状态的数据。</li>
<li>子任务：任务可互相调用，功能非常强大，可用于处理多次跳转，详情页还包含列表的问题，比较复杂，需参考相关文档。</li>
</ol>
<h3 id="32">3.2.对配置的约定</h3>
<ul>
<li>具体数值，直接填入配置框即可</li>
<li>涉及到输入多个列名，多个分隔符等，都默认用空格分割，例如<code>a b c</code></li>
<li>当希望从<code>数据清洗</code>中读取其他列的数据到本参数，使用方括号表达式，例如<code>[col]</code></li>
<li>希望将多个列的数据合并，可使用<code>合并多列</code></li>
<li>配置子任务的模块范围时：<code>1:100</code>表示从1到100， <code>2:-2</code>表示从第2个模块到倒数第二个模块，可参考Python的slice写法</li>
<li>配置子任务的字段映射时，可以用<code>a:b c:d</code>表示a列映射到b列，以此类推。</li>
</ul>
<h2 id="4">4.一些忠告</h2>
<ol>
<li>Hawk除了做爬虫，还能做数据清洗，甚至批量执行命令，需要你来挖掘。</li>
<li>Hawk对代理的支持不够（免费的就知足吧），避免过度抓取导致屏蔽。</li>
<li>记得经常保存任务，尽量将数据写入到数据库而非表里，否则程序可能崩溃难以挽回。</li>
<li>如果任务出现异常，请截图软件，详细描述，将根目录下的log.dat发给buptzym@qq.com，我会尽快予以解答。使用问题烦请在GitHub的issue上提问，其他途径可能不会收到回复。</li>
<li>如果你喜欢Hawk，请star该项目，欢迎给作者打赏，你的鼓励是作者改进软件的最大动力。</li>
</ol>
<h1 id="hawk_1">Hawk工程</h1>
<p>Hawk使用工程(Project)的概念描述一组任务的集合。在工程中，所有的任务可以互相引用，任务也可以访问内部的数据表，连接器和配置。 一个典型的工程包含以下内容：</p>
<ul>
<li>任务： 多个网页采集器和数据清洗</li>
<li>数据表： 缓存的抓取结果，错误表和数据日志等，最大不超过10w</li>
<li>连接器： 访问各种数据库的配置</li>
<li>全局配置</li>
</ul>
<p>打开Hawk后，即可在<code>文件</code>栏中，新建，加载，保存，另存为工程。这些概念和Windows中的标准实现接近，因此不多做介绍。还可以打开最近打开的文件， 直接加载工程。</p>
<p>注意：</p>
<ul>
<li>由于Hawk在不断发展，早期版本的工程可能并不能兼容目前软件。</li>
<li>当工程较大时，加载和保存都会消耗一定的时间。</li>
</ul>
<h2 id="1_1">1.自动保存</h2>
<p>为了提升Hawk运行的稳定性，Hawk3增加了自动保存的功能。 可以在<code>系统配置</code>中，设置自动保存的时间间隔（单位为秒）。当值小于等于0时，则不会自动保存。</p>
<p>保存的内容以xml或hproj形式后缀的文件记录在工程文件中。保存的内容包括：</p>
<ul>
<li>所有数据表(为了降低存储损耗，超过10万的数据表不会保存)</li>
<li>所有任务（包括数据清洗和网页采集器）</li>
<li>所有正在执行的正式线程（Hawk可以记录任务执行的位置，在下次启动时断点续跑）</li>
</ul>
<p>对工作线程的保存时：</p>
<ol>
<li>正式线程是正式处理数据的任务，而非调试模式时自动刷新启动的临时任务。在下次启动时，上次未执行完的任务都会暂停，只有手动重启后才能执行。但并不精确</li>
<li>在重启线程时，可能会有一定的时延，因为线程会将指针移动到上次执行的位置，而这需要一定的时间。通常在10-30秒之内。</li>
<li>当加载或保存较大的数据表时，可能会有卡顿的情况。</li>
</ol>
<h2 id="2hawk">2.Hawk工程介绍</h2>
<p>Hawk的工程文件为xml或hproj， 在保存工程时，可以在文件保存对话框中，选取要保存的文件格式。</p>
<ul>
<li>xml: 可直接检查数据，并被其他语言所处理。但当其中包含较大的数据表时，xml文件由于其冗余性，体积会很大。</li>
<li>hproj是zip压缩后的xml, Hawk在加载hproj后，会自动将其解压，并按xml格式解析之，反之过程则过程相反。</li>
<li>不论是xml还是hproj，其内部的结构都是一致的，通过xml树描述了层次结构，子节点用Children来表达。</li>
<li>由于xml可读性不强，未来可能会增加基于yaml的配置</li>
</ul>
<h2 id="3_1">3.全局配置系统</h2>
<p>Hawk5新增了全局配置系统，方便在不同的任务间共享参数，并通过一次切换，更改所有任务的行为。</p>
<p>例如，针对链家开发爬虫时，不同的城市会有细微区别，如xpath，或名称... 因此可针对不同城市建立配置，切换配置即可在不同城市间切换，Hawk的模块在执行时会动态地获取这些数据。大大提升了重用性。</p>
<h3 id="31_1">3.1.配置文件语法</h3>
<p>Hawk采用了非常简单的配置写法，即yaml。每行一个配置，键值之间用英文冒号，即:表示。 用#号来代表注释，所有以#号开头的行都会被当成注释而忽略。例如：</p>
<pre><code>`#这是一行注释`
city: bj
xpath: your_xpath
</code></pre>

<p>在数据清洗的任意模块，大部分参数都能支持引用全局配置，语法是{key_name}，例如{city}，会将配置中city项的值拷贝过来。</p>
<p>注意:</p>
<ul>
<li>使用方括号语法<code>[]</code>是访问其他列的数据</li>
<li>大括号语法<code>{}</code>是访问全局配置的数据。</li>
<li>如果全局配置里没有对应项，则返回带大括号的原始字符串。</li>
<li>虽然使用了yaml作为配置文件，但并不支持完整的语法(如数组和层次字典等)，只能支持单层的的键值对。</li>
</ul>
<h3 id="32_1">3.2.新建和切换配置组</h3>
<p>//TODO: 增加图片
点击edit按钮，可增加新的配置组。 选择对应的配置组后，即可全局生效。</p>
<h1 id="_2">主要组件介绍</h1>
<h2 id="1hawk">1.Hawk的关键概念</h2>
<ul>
<li>任务： 系统仅仅提供了两种任务：  网页采集器 和数据清洗，任务可以被新建，保存和加载。</li>
<li>模块： 一个任务会包含多个模块，例如数据清洗中会有<code>从文本生成</code>,<code>从爬虫转换</code>等</li>
<li>工程： 多个任务组成一个工程，工程可以以xml方式保存和加载</li>
<li>数据表: 在内存中存储的数据表，速度快，但是容量有限，存储小型数据时使用</li>
<li>数据库(连接器)： Hawk通过连接器连接不同的数据库，如MongoDB，sqlite等。</li>
<li>列： 数据清洗里的列，可参考像Excel里的列，在 网页采集器 里，一个属性对应一个列</li>
<li>文档： 可理解为数据清洗里的一行，它是键值对构成的字典，如<code>key1:value,key2:value2</code></li>
<li>单元格 ： 文档中的一个单元格，就像Excel 那样</li>
<li>流:  多个文档的序列，可能是有限或无穷的，在早期版本的Hawk中，这个概念大量使用。</li>
<li>线程： 任务在启动时，会有一个(串行)或多个(并行)线程，可以在工作线程中对其进行暂停和删除。</li>
</ul>
<h2 id="2hawk_1">2.Hawk任务市场</h2>
<p>为了方便用户间共享高质量的工程，形成良好的社区环境，在Hawk5中提供了市场功能。
//TODO</p>
<h2 id="3_2">3.调试系统</h2>
<p>除了在调试模式下进行操作之外，Hawk还提供了丰富的工具来确定错误的位置。</p>
<h3 id="31_2">3.1.调试与探查窗口</h3>
<p>//TODO
调试探查窗口可以方便地展示每个模块的输入量，输出量，因空而跳过的数量，以及配置和描述等，一目了然。</p>
<h3 id="32_2">3.2.系统级窗口</h3>
<p>如何了解总的http请求次数和错误数？ 在 系统设置-&gt; http请求详情里，详细地给出了请求数，被禁止数，因错误而跳过等数量。 点击 <code>清空数据</code>，即可将计数器置0.</p>
<h3 id="33">3.3.确定模块的输入和输出</h3>
<p>在单步调试模式时，该模块输入的列，会在数据清洗的最上方用蓝色表示，输出列会用绿色表示。</p>
<h2 id="4_1">4.日志功能</h2>
<p>Hawk包含了几类日志功能， 使用log4net作为日志系统，分为INFO, DEBUG, ERROR, FATAL ,WARNING五种等级。</p>
<ul>
<li>在线界面日志：在UI的最下方，但是只能显示本次启动日志，同时不能太多，否则会有性能问题</li>
<li>日志文件， log.dat， 本质还是文本文件，可使用记事本打开，超过10M则会创建新文件。</li>
<li>弹出对话框： 右上角会有弹出式浮窗。可通过 系统设置 中进行设置</li>
</ul>
<p>如何改变日志的级别？ 当发现现有日志太多或太少，可以在主菜单-&gt; 调试-&gt; 日志级别 设置</p>
<h2 id="5">5.多国语言</h2>
<p>Hawk5支持了多国语言引擎，会根据操作系统语言自动切换显示的语言。 目前支持的语言包括；</p>
<ul>
<li>中文(zh_CH)</li>
<li>English (en_US)</li>
</ul>
<p>还可以手工设置语言， 在 <code>系统设置</code>， <code>语言</code>中切换，下一次启动时，会按上一次设置保存的语言显示。</p>
<p>Hawk凭借WPF的强大功能，一定程度上支持语言热切换，但依然会出现不能全部顺利切换的情形。因此建议在设置语言后，通过重启使语言生效。</p>
<h3 id="51">5.1.新增其他语言</h3>
<p>如果你愿意为Hawk的国际化贡献力量。欢迎新增语言，Hawk新增语言非常简单，在程序的执行目录的Lang文件夹，以xaml格式保存了各国语言的配置文件。拷贝zh_CH.xaml, 并将其中的中文内容替换为对应语言即可。注意：</p>
<blockquote>
<p>如果只是希望国际化界面部分，则只需修改不带xml:space=preserve标签部分的内容。而包含该标签的内容，基本都用于显示文档。当然我更希望你可以翻译全部内容，否则没有文档的Hawk是非常难以使用的。</p>
</blockquote>
<h2 id="6">6.帮助文档系统</h2>
<p>由于Hawk的使用较为复杂，因此提供了内置的文档系统。</p>
<ul>
<li>在绝大多数的按钮和菜单上，放置鼠标超过3秒钟，就会弹出完整的介绍和帮助。</li>
<li>所有的模块在配置时，都可以在配置后显示其使用文档，包括功能简介，参数名和对应介绍，注意事项等。</li>
<li>点击：帮助，即可弹出全局文档系统，在文档中，支持字体放缩，关键字搜索等，方便快速定位内容。</li>
</ul>
<p>Hawk的文档系统分为<code>新手模式</code>和<code>高手模式</code>：</p>
<ul>
<li>模式的切换，可以在系统配置，显示详细描述中进行切换</li>
<li>新手模式：文档详尽，尤其是在数据清洗的模块列表中，以详细介绍的形式呈现，方便直观地了解各模块功能</li>
<li>老手模式：文档极简，仅提供新手模式第一段的内容。</li>
</ul>
<h4 id="_3">自动文档生成</h4>
<p>由于软件在不停地优化升级，为了降低作者编写文档的负担，Hawk采用了自动文档生成的方式，各模块的介绍都基于C#的反射进行，因此可能会出现友好度不足的问题。</p>
<p>您也可以在线上访问Hawk的全部文档：
TODO:</p>
<h1 id="_4">数据表和数据库连接</h1>
<h2 id="1_2">1.数据表</h2>
<p>当加载了数据集时，在本视图中，就可对其查看和编辑:</p>
<ol>
<li>点击右键，可以对数据集进行删除，修改名称等</li>
<li>将数据集拖拽到下方的图标上，如拖到回收站，即可删除该模块。</li>
<li>双击数据集可查看模块的内容。 将数据集拖拽到数据清洗图标上，可直接对本数据集做数据清洗。</li>
</ol>
<p><img alt="数据集视图" src="http://static.zybuluo.com/buptzym/kfz2k0xfvbjtun5ah6hlxoph/QQ%E6%88%AA%E5%9B%BE20160501105734.jpg" /></p>
<h2 id="2_1">2.数据库连接器</h2>
<p>能够添加来自不同数据源的连接器， 并对数据进行加载和管理：</p>
<ul>
<li>在空白处，点击右键，可增加新的连接器</li>
<li>在连接器的数据表上，双击可查看样例</li>
<li>点击右键，可以将数据加载到内存中。</li>
</ul>
<p><img alt="连接器配置" src="http://static.zybuluo.com/buptzym/cympkkptyzq6r370ositd2dh/QQ%E6%88%AA%E5%9B%BE20160501105629.jpg" /></p>
<p>目前支持的连接器包括：</p>
<ul>
<li>MongoDB</li>
<li>sqlite</li>
<li>文件读写</li>
<li>MySql(测试不完全)</li>
</ul>
<h3 id="21mongodb">2.1.MongoDB</h3>
<p>提供MongoDB交互的数据库服务</p>
<h4 id="_5">配置设置</h4>
<p>在安装MongoDB之后，在空白位置点右键，即可选择插入一个<code>MongoDB连接器</code>，在服务器地址，用户名和密码，数据库名称上填写所需的字段，然后点击<code>连接数据库</code>即可。</p>
<p>如果你是小白用户，用上面的方法安装了MongoDB，则数据库地址填写<code>127.0.0.1</code>(代表本地)，用户名和密码为空，数据库名称填写你想要的任何名字皆可。</p>
<h4 id="mongodb">MongoDB安装</h4>
<p>已经安装过的可以自行跳过。</p>
<p>可以从这里下载笔者已经打包好的安装包，之后解压后，在bat脚本上点击右键，以管理员模式执行，就会默认安装到D盘上并启动服务，非常方便。</p>
<blockquote>
<p>https://files.cnblogs.com/files/buptzym/mongodb_windows.zip</p>
</blockquote>
<p>MongoDB本身包含32位和64位两种版本，前者只支持最大2GB的数据集合。但32位能装在64位系统上，反过来就不成。因此提供的安装包是32位版本的。如果想装64位，可以参考网络上其他教程。</p>
<p>安装之后，可以在任务管理器的<code>服务</code>上，检查是否已经包含了<code>正在运行</code>的MongoDB服务</p>
<h3 id="22sqlite">2.2.SQLite</h3>
<p>SQLite是一种简单的文件数据库，使用方便，并可由其他程序读取，推荐使用
使用sqlite非常简单，新建sqlite连接器后：</p>
<ul>
<li>点击‘加载’，加载已有的数据库</li>
<li>点击'新建'，即可创建新的sqlite的db文件，指定路径后，点击连接即可</li>
<li>sqlite对表头只支持英文</li>
</ul>
<h3 id="23">2.3.文件读写</h3>
<h4 id="csv">CSV文件</h4>
<p>输出文本CSV逗号分隔文件
默认列间以\t分割，每行一条数据
CSV文件的读写速度是所有文件中最快的，值得注意数据行本身应不包含分割符，否则会导致解析失败。</p>
<h4 id="xml">XML文件</h4>
<p>输出和输入XML文件</p>
<h4 id="excel">EXCEL文件</h4>
<p>输出标准EXCEL文件，效率较低</p>
<h1 id="_6">网页采集器</h1>
<p>网页采集器 模拟了浏览器的设计，填入网址，点击刷新，即可获取对应地址的html源码。</p>
<ul>
<li>左侧的区域，显示了html源码和浏览器视图，可通过tab页切换。</li>
<li>右侧配置区域，可对关键字进行搜索，并对面前所有的属性进行管理。</li>
<li>TODO:下侧区域</li>
</ul>
<p>网页采集器 不能单独工作，而是沟通 网页采集器 和数据清洗的桥梁。本质上说， 网页采集器 是针对获取网页而特别定制的<code>数据清洗模块</code>。</p>
<h2 id="1_3">1.主要配置介绍</h2>
<h3 id="11_1">1.1.列表根路径</h3>
<p>列表根路径是所有属性的XPath公共部分，能简化XPath编写，提升兼容性。只能在多文档模式下工作。
你可以通过Hawk自动分析根路径，或手动设置。</p>
<h3 id="12">1.2.自动规约列表路径</h3>
<p>以例子来说明，使用手气不错后，嗅探器会找到列表节点的父节点，以及挂载在父节点上的多个子节点，从而形成一个树状结构</p>
<ul>
<li>父节点(/html/div[2]/div[3]/div[4])</li>
<li>子节点div[1]</li>
<li>子节点div[2]
...</li>
</ul>
<p>每个节点要抽取下面的属性:</p>
<ul>
<li>属性1(/a[1])</li>
<li>属性2(/a[2]/@href)</li>
<li>..</li>
</ul>
<p>为了能获取父节点下所有的div子节点，因此列表根路径就是<code>/html/div[2]/div[3]/div[4]/div</code>。 注意：父节点Path路径末尾是不带序号的，这样才能获取多个子节点。可以这么理解，列表根路径就是不带结尾数字的父节点路径。</p>
<p>有时候，父节点的xpath是不稳定的，举个例子，北京上海的二手房页面，上海会在列表上面增加一个广告banner，从而真正的父节点就会发生变化，比如向后偏移了<code>div[1]变成了div[2]</code>。为了应对这种变化，通常的做法是手工修改【列表根路径】</p>
<h3 id="13">1.3.手动设置根路径</h3>
<h3 id="14">1.4.工作模式</h3>
<ul>
<li>多文档: 会输出多份文档，通常在网页的列表页中使用</li>
<li>单文档:  输出单份文档，一般在网页的详情页中使用</li>
<li>不进行转换:  直接输出网页源代码，放置于Content列中</li>
</ul>
<p>注意:</p>
<ul>
<li>当在 多文档或 单文档模式，且属性数量为0时，也和 不进行转换行为一致</li>
</ul>
<h2 id="2_2">2.抓取网页数据</h2>
<p>网页采集器需配合数据清洗使用，才能 使用 网页采集器 获取网页数据，拖入的列需要为超链接</p>
<h3 id="21get">2.1.一般的get请求</h3>
<p>一般情况下, 将从爬虫转换拖入到对应的URL列中，通过下拉菜单选择要调用的爬虫名称，即可完成所有的配置：</p>
<p><img alt="请求配置" src="http://static.zybuluo.com/buptzym/hgwpmxsjz0gun5epqt2087wh/image_1avc2t94d3l51sofkah8m1lrrm.png" /></p>
<p>本模块是沟通网页采集器和数据清洗的桥梁。本质上说，网页采集器是针对获取网页而特别定制的<code>数据清洗模块</code>。</p>
<p>你需要填写<code>爬虫选择</code>，告诉它要调用哪个采集器。注意：</p>
<ul>
<li>早期版本的Hawk,会默认选择在<code>算法模块</code>的第一个网页采集器，但实践证明这样会导致问题，后来就取消了功能。</li>
</ul>
<h3 id="22post">2.2.实现post请求</h3>
<p>web请求中，有两种主要的请求类型:post和get。 使用POST能支持传输更多的数据。更多的细节，可以参考http协议的相关文档，网上汗牛充栋，这里就不多说了。</p>
<p>post请求时，Hawk要给服务器需要传递两个参数：url 和post。一般来说，在执行post请求时，url是稳定的，post值是动态改变的。</p>
<p>首先要配置调用的网页采集器为<code>post</code>模式（打开网页采集器，请求详情，模式-&gt;下拉菜单）。</p>
<p>之后，需要将<code>从爬虫转换</code>拖到要调用的url列上。如果没有url列，可以通过<code>添加新列</code>，生成要访问的url列。</p>
<p>之后，我们要将post数据传递到网页采集器中。你总是可以通过<code>合并多列</code>拼接或各种手段，生成要Post的数据列。之后，可以在<code>从爬虫转换</code>中的<code>post数据</code>中，填写<code>[post列]</code>， 而<code>post列</code>就是包含post数据的列名。 注意：</p>
<ul>
<li>Hawk使用方括号语法，来引用其他列的值作为当前的参数</li>
</ul>
<h2 id="3_3">3.手气不错</h2>
<p>这是Hawk最被人称赞的功能！在新的Hawk3中，该功能被极大地增强。</p>
<h3 id="31_3">3.1.多文档下的手气不错</h3>
<p>一般来说，输入网址加载页面后，点击手气不错即可，Hawk会自动按照优先级将列表数据抓取出来
<img alt="手气不错配置" src="https://images2018.cnblogs.com/blog/287060/201805/287060-20180506160854095-924772830.png" /></p>
<p>左右切换选择你想要的数据集，之后在下面的属性栏对结果进行微调。
添加一个属性，手气不错就能更准确地进行。添加两个属性，即可选定唯一区域。</p>
<h3 id="32_3">3.2.单文档模式的手气不错</h3>
<p>Hawk3新增功能，当网页中包含多达几十种属性时，挨个添加会变得特别烦琐，这在某种商品属性页特别常见。
为了解决这个问题，将关键字加入到<code>搜索字符</code>中，此时不要将其添加到属性列表中，直接点击手气不错即可。</p>
<h3 id="33_1">3.3.手动模式</h3>
<p>在手气不错不能工作或不符合预期时，需要手工给定几个关键字， 让Hawk搜索关键字， 并获取在网页中所在的位置(XPath)。
填入搜索字符，能够成功获取XPath, 编写属性名称，点击{{}}，即可添加一个属性。类似地，再填入30535，设置属性名称为“单价”，即可添加另外一个属性。</p>
<p>在<code>搜索字符</code>的文本框中，输入你要获取的关键字，由于关键字在网页中可能出现多次，可连续点击<code>继续搜索</code>，在多个结果间切换，左侧的html源码会对搜索的结果进行高亮。</p>
<ol>
<li>请注意观察搜索的关键字在网页中的位置，是否符合预期，否则抓取数据可能会有问题。尤其在 多文档模式。</li>
<li>如果需要抓取本页面的多块数据，可新建多个<code>网页采集器</code>，分别进行配置。</li>
<li>如果发现有错误，可点击<strong>编辑集合</strong>，对属性进行删除，修改和排序。</li>
<li>你可以类似的将所有要抓取的特征字段添加进去，或是直接点击 手气不错 ，系统会根据目前的属性，推测其他属性。</li>
</ol>
<h2 id="4_2">4.动态嗅探</h2>
<h3 id="41">4.1.什么是动态页面？</h3>
<p>动态瀑布流和ajax的页面，通常按需返回html和json.</p>
<p>老式网站在刷新时会返回页面的全部内容，但若只更新部分，即可大大节约带宽。该方式叫ajax，服务端传递xml或者json到浏览器，浏览器的js代码执行，并将数据渲染到页面上。 因此，获取数据的真实url，不一定显示在浏览器地址栏，而是隐藏在js调用中。本质上，javascript发起了新的隐藏http请求来获取数据，只要能模拟之，就能像真实浏览器一样获取所要数据。参考<a href="https://baike.baidu.com/item/ajax/8425?fr=aladdin">百度百科的介绍</a></p>
<h3 id="42hawk">4.2.Hawk自动获取动态请求</h3>
<p>通过浏览器和抓包，可以获取这些隐藏请求，但需要对HTTP请求的原理比较熟悉，不适合于初学者。
Hawk简化了流程，采用自动嗅探的方式来进行。Hawk成为后端代理，会拦截和分析所有系统级Http请求，并将包含关键字的请求筛选出来 （基于fiddler）</p>
<p>当搜索字符时，若没有在当前页面中找到该关键字，Hawk会有提示，“是否启动动态嗅探？”此时Hawk会弹出浏览器并打开所在网页。您可将页面拖到包含关键字的位置，Hawk会自动记录和过滤包含关键字的真实请求， 检索完毕后，Hawk会自动回弹。</p>
<h3 id="43">4.3.如果无法自动嗅探?</h3>
<p>由于Hawk有拦截功能，会被浏览器认为不安全，有以下两种方案：
可以修改浏览器安全设置。    TODO:  增加浏览器的安全设置
//TODO</p>
<h3 id="44">4.4.注意事项</h3>
<ol>
<li>有时直接将url拷贝到Hawk，并使用手气不错时，也能获取到数据。这是因为很多网站对第一页和其他页分别作了不同的处理。第一页内容会跟着整体frame返回回来。但之后页面内容就通过ajax单独返回了。
有时针对第一页做了大量的XPath开发，却最后发现无法在其他页面使用，多半就是上面提到的问题（一脸懵逼）。因此经验上，建议翻到其他页面上再做请求。</li>
</ol>
<p>超级模式能将网页中所有的javascript, json, xml都转换为HTML DOM树，从而实现属性提取和手气不错。</p>
<h2 id="5_1">5.超级模式</h2>
<p>为了能让动态网页也能使用<code>添加属性</code>和<code>手气不错</code>，Hawk在嗅探后默认会开启<code>超级模式</code>。 超级模式能将网页中所有的javascript, json, xml都转换为HTML DOM树，从而实现属性提取和手气不错。
超级模式极大的简化了动态请求的处理，但它依然可能有以下问题:</p>
<ul>
<li>性能较差，大量的字符解析，js模式树解析</li>
<li>兼容性一般：不是所有的文本都能转成树结构，因此必要时需要使用手动模式处理。</li>
</ul>
<h2 id="6_1">6.超级模式的原理</h2>
<p>网页采集器的功能是获取网页中的数据（废话）。通常来说，目标可能是列表（如购物车列表），或是一个页面中的固定字段（如JD某商品的价格和介绍，在页面中只有一个）。因此需要设置其读取模式。传统的采集器需要编写正则表达式，但方法过分复杂。</p>
<p>如果认识到html是一棵树，只要找到了承载数据的节点即可，之后用XPath来描述。</p>
<p><img alt="手气不错原理" src="http://static.zybuluo.com/buptzym/y0l0aorvdas5ydsg8xcz9jx2/image_1b0keius5171011j6l911tsg109fg.png" /></p>
<p>手工编写XPath也很复杂，因此软件可以通过关键字，自动检索XPath，提供关键字，软件就会从树中递归搜索包含该数据的叶子节点。因此关键字最好是在页面中独一无二的。</p>
<p>如上图所示，只要提供“北京”和“42”这两个关键字，就能找到parent节点， 进而获取div[0]和div[1]这两个列表元素。通过div[0]和div[1]两个节点的比较，我们就能自动发现相同的子节点（name,mount）和不同的节点（北京:上海,37:42）。相同的节点会保存为属性名，不同的节点为属性值。但是，不能提供<code>北京</code>和<code>37</code>，此时，公共节点是<code>div[0]</code>， 这不是列表。</p>
<p>软件在不提供关键字的情况下，也能通过html文档的特征，去计算最可能是列表父节点（如图中的parent）的节点，但当网页特别复杂时，猜测可能会出错。</p>
<h2 id="7">7.设置共享请求参数的采集器名称</h2>
<p>为了抓取一个网站的不同数据，我们需要多个 网页采集器 。但是访问网站需要登录和cookie，难不成每个采集器都要设置对应的请求参数吗？
采集器的属性对话框中，可以设置<code>共享源</code>,也就是要共享的 网页采集器 的名称。例如设置为<code>链家采集器</code>，那么本采集器的请求参数，都会在执行时，动态地从链家采集器中获得。这样就极大地简化了配置过程。</p>
<h2 id="8xpathcss">8.附录：XPath和CSS写法</h2>
<h3 id="81xpath">8.1.XPath</h3>
<p>关于XPath语法，可参考<a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp">教程</a></p>
<p>XPath可以非常灵活，例如：</p>
<ul>
<li>bookstore 选取 bookstore 元素的所有子节点。</li>
<li>/bookstore    选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</li>
<li>bookstore/book    选取属于 bookstore 的子元素的所有 book 元素。</li>
<li>//book    选取所有 book 子元素，而不管它们在文档中的位置。</li>
<li>bookstore//book   选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</li>
<li>//@lang   选取名为 lang 的所有属性。</li>
<li>//@src 可匹配所有src标签</li>
<li>//title[@lang] 选取所有拥有名为 lang 的属性的 title 元素
还可以通过<code>|</code>对多个表达式进行混合，Hawk支持了完整的XPath语法，因此不论是<code>网页采集器</code>以及数据清洗的<code>XPath</code>转换器，都能极其灵活地实现各种需求。</li>
</ul>
<h3 id="82cssselector">8.2.CSSSelector</h3>
<p>多数情况下，使用XPath就能解决问题，但是CSSSelector更简洁，且鲁棒性更强。关于它的介绍，可<a href="http://www.w3school.com.cn/cssref/css_selectors.asp">参考教程</a>
当然，大部分情况不需要那么复杂，只要记住以下几点：</p>
<ul>
<li><code>.name</code> 获取所有id为name的元素</li>
<li><code>#name</code> 获取所有class为name的元素</li>
<li><code>p</code> 获取所有p元素</li>
<li><code>ul &gt; li</code> 获取所有父节点是ul的li元素</li>
</ul>
<h1 id="_7">数据清洗</h1>
<p>数据清洗是一种任务，包括几十个子模块， 这些子模块包含四类：生成， 转换， 过滤和执行。</p>
<p><img alt="丰富的模块" src="https://images2018.cnblogs.com/blog/287060/201805/287060-20180506160120254-60486829.png" /></p>
<p>数据清洗可以通过组合多个不同的子模块，生成多样的功能，通过拖拽构造出一个工作流，它能够产生一个有限或无限的文档序列。比如下面：</p>
<p><img alt="image_1auq4oooc1m8m9tc02sjv1j4o9.png-71.6kB" src="http://static.zybuluo.com/buptzym/gzr3u0z80478s31u9v1zdfw5/image_1auq4oooc1m8m9tc02sjv1j4o9.png" /></p>
<h2 id="1_4">1.参数说明</h2>
<h3 id="11_2">1.1.工作模式</h3>
<ul>
<li>多文档 :生成多条数据（文档）</li>
<li>单文档 :  单文档</li>
<li>不进行转换: 按照原始数据返回</li>
</ul>
<h2 id="2_3">2.几种模块的介绍</h2>
<h3 id="21">2.1.转换器</h3>
<p>转换器是最为常用的一种类型，当然它的使用也是最复杂的。</p>
<p>转换器有三种子类型：</p>
<ul>
<li>ColumnUDF: 单文档： 只对一个列有效，如<code>提取数字</code>,</li>
<li>UDF: 单文档：如删除该列，它仅涉及文档内部的修改，可能会影响多个列</li>
<li>UDAF: 多文档：典型的如 多文档模式下从爬虫转换，每一行url都可能生成20个甚至更多的文档，它的行为cross(交叉)模式下的生成器。</li>
</ul>
<p>ColumnUDF是UDF的特例， UDF是UDAF的特例（只产生一种）
绝大多数转换器都是UDF类型。但同一个转换器在不同的配置下，可能会有多种行为，例如<code>从爬虫转换</code>，如果选择的 网页采集器 为单文档(单文档)模式，则该转换器为UDF模式，若为 多文档模式，则为UDAF模式。</p>
<ul>
<li>输入列: 就是要输入这个模块的列，（Hawk1时代也称作原列名）;</li>
<li>输出列: 则指的是模块输出的列。 UDF模式下，如果新列名为空，则新列名等于原列名，直接修改在原始列上。</li>
</ul>
<h3 id="22udaf">2.2.关于UDAF的必要说明</h3>
<p>当你使用多文档模式的爬虫，或单转多时，虽然生成了多个文档，但原始的数据（如URL）不见了。这是因为Hawk丢弃了这些列。</p>
<p>经过大量实践，如果不这么做，每个新数据后面，都会跟上原始的老数据，如果1转20，则老数据会重复生成20次，这是没有必要的。有时不得不拖入大量的<code>删除该列</code>来处理。
当然，有时转换时需要包含原始数据的部分列，则可在转换器的<code>新列名</code>中填写要<code>鲤鱼跳龙门</code>的列的名称，中间用空格分割。</p>
<ul>
<li>在Hawk3中，还支持在新列名中输入<code>*</code>号，此时所有的原始列都会添到新的文档之中。</li>
<li>注意，UDAF的新列可能会覆盖掉原始列的数据，因此多检查列名，避免意料之外的覆盖</li>
</ul>
<h3 id="23_1">2.3.过滤器</h3>
<p>过滤器可以在流中，过滤掉不符合条件的文档（也就是横向过滤）。</p>
<ul>
<li>可勾选<code>反向</code>，此时只会留下不符合条件的文档。即对原始结果做了取反。</li>
<li>如何对列过滤？ 目前Hawk并未提供该功能，可通过拖入多个删除该列来实现</li>
</ul>
<p>Hawk3的过滤器还支持几种不同的行为，即过滤模式，分别是：</p>
<ul>
<li>按行过滤</li>
<li>成功后通过之后的所有行</li>
<li>失败后通过之后所有行</li>
</ul>
<h3 id="24">2.4.执行器</h3>
<p>执行器是负责将Hawk的结果传送到外部环境的工具。
你可以写入数据表，数据库，甚至执行某个特定的动作，或是生成文件等等。
在调试模式下，执行器都是不工作的。这是为了避免产生副作用。否则，每刷新一遍数据，就会向数据库中写入，这显然是不可接受的。
只有在运行模式下，才会使执行器生效。</p>
<h3 id="25">2.5.生成器</h3>
<p>顾名思义，生成器就是通过一定的参数，生成一个文档列表的组件。生成器通常位于任务开头，可从文本，文件，数据库读取数据。 或者从一个区间内生成纵向的数字和时间。</p>
<p>它与转换器有很多相似之处，但是明显不同：</p>
<ul>
<li>转换器必须有输入，而生成器不需要。生成器一般需要输出列，来保存其输出的数据。</li>
<li>生成器输出的数据可以与原始数据进行横向/纵向/交叉拼接，这远比转换器灵活</li>
<li>生成器的参数都支持方括号语法，但转换器只有部分支持</li>
</ul>
<p>当生成器生成数据后，如何与原始的数据组合呢？有四种模式：</p>
<ul>
<li>按行纵向合并</li>
<li>笛卡尔交叉</li>
<li>交错交叉</li>
<li>按列横向合并</li>
</ul>
<p><img alt="生成器的四种模式" src="https://images2018.cnblogs.com/blog/287060/201805/287060-20180506160537169-568274026.png" /></p>
<p>拖入的模块顺序是非常重要的，一个常见问题是顺序不对，导致生成的数据不符合预期。数据清洗可通过 从爬虫转换 来调用 网页采集器 ，也可以通过<code>子任务</code>来调用其他数据清洗，是组合各种模块和任务的工厂。</p>
<h2 id="3_4">3.运行模式</h2>
<h3 id="31_4">3.1.调试模式</h3>
<p>在编辑任务的过程中，处于<strong>调试模式</strong>，它具备如下特点：</p>
<ul>
<li>所有执行器都不工作，避免副作用</li>
<li>点击下方中间的刷新按钮，或修改配置，展示的数据会自动刷新</li>
<li>只能运行在串行模式上</li>
<li>所见即所得，只显示一定数量的数据（通过采样量修改）</li>
<li>可以禁用或启用某些模块，观察效果</li>
<li>会加入web请求和读取文件的缓存， 来提升预览速度（可能会导致一些问题）</li>
<li>输入列和输出列会用不同的颜色进行表示</li>
</ul>
<p>在调试时，从爬虫转换模块可能会请求web数据，为了提升性能，该模块对请求做了缓存。保证数据只需获取一次，如果想强制刷新数据，将从爬虫转换模块禁用，再启用，原始缓存数据就会被擦除。</p>
<p>Hawk支持两种执行模式:</p>
<h3 id="32_4">3.2.串行模式</h3>
<p>只有点击<strong>执行</strong>时，才会切换到执行模式。执行时，可工作在串行模式/并行模式
在串行模式下， 所有任务串行执行，速度慢，但对网站压力小，不容易被封锁。为了进一步降低执行速度，可以设置延时时间，此时每次网络请求前，都会延时一定时间。
注意:</p>
<ol>
<li>当执行器包含类似"向文件中追加内容"的操作时，强烈建议使用串行模式，因为Hawk没有加入多线程锁，有可能会导致冲突。</li>
<li>建议完成爬虫设计后，先进行串行模式，初步观察是否正确，之后再设置并行模式大量抓取。</li>
</ol>
<h3 id="33_2">3.3.并行模式</h3>
<p>极大地加快了抓取速度，但很容易被封锁。 Hawk使用了线程池的机制，可以设置最大工作线程数，只有之前的工作线程完成工作，才会填入新的任务。否则过多的线程会迅速占用所有系统资源。</p>
<p>相比于Hawk2, Hawk3会自动分析可以并行的位置，因此多数情况下，直接运行就可以了。但是如果你想自定义并行化的行为，就需要阅读下面的内容。</p>
<h2 id="4_3">4.线程管理</h2>
<p>不论是调试还是执行模式，系统都会在任务管理视图中增加一个或多个线程。
你可以勾选，或取消勾选部分或全部线程，暂停或取消它们。当网站限制抓取时，可以暂停所有线程，等恢复后再次执行。</p>
<p>注意:</p>
<ol>
<li>当工作流有误时（比如该列所有数据都空，却在该列添加了 空对象过滤器，那么所有数据都会被过滤）可能不会产生任何数据输出。此时进度条并不会向前推进，产生卡死的假象。此时可强行将其删除</li>
<li>线程删除的流程是：先安全将其取消，如果线程无响应，则会直接将其杀死</li>
</ol>
<h3 id="41_1">4.1.单步调试</h3>
<p>Hawk模仿了播放器和调试器，在调试模式下有<code>步</code>的概念，例如所在位置是6/20， 则说明总共有20个模块，只生效前面6个模块。 可以通过左右单击，或直接回退到开头、末尾来进行调试。</p>
<p>左侧显示了当前所有的模块，顺序和它们的输入输出列，双击上面的模块可对其进行配置，右键可删除。单选列表上的任一模块t，系统就会只仿真前t步的效果。 本质上，单步调试只是提取了工作流的一部分进行操作。   你可以在单步调试中，拖入新的模块。模块会自动插入在工作流中间。</p>
<p><img alt="上下拖拽，右键配置每一步的参数" src="https://images2018.cnblogs.com/blog/287060/201805/287060-20180506155928987-1522342347.png" /></p>
<p>有时为了在单步调试过程中查看模块的属性，可勾选界面右下角的<code>调试详情</code>，此时可直接显示当前模块的属性。</p>
<p><img alt="模块数量" src="https://images2018.cnblogs.com/blog/287060/201805/287060-20180506160222760-1330008382.png" /></p>
<p>当模块有正常产出时， 模块的标志会变成蓝色，因此从上到下，第一个不是蓝色的模块，就有可能是有问题的模块。</p>
<h1 id="_8">转换器</h1>
<h2 id="baidulocation">搜索位置(BaiduLocation)</h2>
<p>通过百度API获取当前地标的经纬度坐标，需要拖入代表地名的列
在Hawk 3之后的版本，需要在百度地图API中注册账户，并将token填入配置中，参考:</p>
<blockquote>
<p>http://lbsyun.baidu.com/index.php?title=webapi</p>
</blockquote>
<h3 id="region">所属地市(Region):</h3>
<ul>
<li>类型:String 默认值:北京</li>
<li>通过城市名称进行信息检索</li>
</ul>
<h3 id="tag">标签(Tag):</h3>
<ul>
<li>类型:String</li>
<li>如医院，美食等</li>
</ul>
<hr />
<h2 id="ipgetiplocation">获取IP的坐标(GetIPLocation)</h2>
<p>获取某一ip地址的经纬度坐标</p>
<hr />
<h2 id="getroute">获取路径信息(GetRoute)</h2>
<p>从当前地名，运动到对应坐标所需的时间</p>
<h3 id="dest">目标位置(Dest):</h3>
<ul>
<li>类型:String</li>
<li>通过城市名称进行信息检索</li>
</ul>
<h3 id="sourcecity">源城市(SourceCity):</h3>
<ul>
<li>类型:String 默认值:北京</li>
<li>通过城市名称进行信息检索</li>
</ul>
<h3 id="destcity">目标城市(DestCity):</h3>
<ul>
<li>类型:String 默认值:北京</li>
<li>通过城市名称进行信息检索</li>
</ul>
<h3 id="modeselector">运动方案(ModeSelector):</h3>
<ul>
<li>类型:string选项 默认值:公交</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="nearbysearch">检索附近(NearbySearch)</h2>
<p>获取当前经纬度某一半径范围内的所有地物，需要拖入的为代表经度的列</p>
<h3 id="query">查询地物，如<code>医院</code>,<code>商场等</code>(Query):</h3>
<ul>
<li>类型:String</li>
<li>如公园，车站等</li>
</ul>
<h3 id="lng">纬度列(Lng):</h3>
<ul>
<li>类型:String 默认值:pos_lng</li>
<li>代表纬度所在的列</li>
</ul>
<h3 id="radius">搜索半径(Radius):</h3>
<ul>
<li>类型:Int32 默认值:2000</li>
<li>没有描述</li>
</ul>
<h3 id="allresult">所有结果(AllResult):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="nlptf">自然语言处理(NlpTF)</h2>
<p>通过语言云获取的NlpTF功能，包括分词，词性标注，主题提取等</p>
<h3 id="resulttyperesulttype">ResultType(ResultType):</h3>
<ul>
<li>类型:ContentType 默认值:Text</li>
<li>没有描述</li>
</ul>
<h3 id="patternpattern">Pattern(Pattern):</h3>
<ul>
<li>类型:Pattern 默认值:分词</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="transtf">语言翻译转换(TransTF)</h2>
<p>从当前语言翻译为目标语言(调用百度API)</p>
<h3 id="clientid">应用中心账号(ClientID):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="keykey">key(Key):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="sourcesource">Source(Source):</h3>
<ul>
<li>类型:string选项 默认值:自动检测</li>
<li>没有描述</li>
</ul>
<h3 id="targettarget">Target(Target):</h3>
<ul>
<li>类型:string选项 默认值:自动检测</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="addnewtf">添加新列(AddNewTF)</h2>
<p>为数据集添加新的列，值为某固定值</p>
<h3 id="newvalue">生成值(NewValue):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="autoindextf">自增键生成(AutoIndexTF)</h2>
<p>自动生成一个从起始索引开始的自增新列</p>
<h3 id="startindex">起始索引(StartIndex):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="renametf">列名修改器(RenameTF)</h2>
<p>对列名进行修改,常用</p>
<p>拖入的列是要修改的列，填写<code>输出列</code>后，原始列被删除，内容转移到新列上</p>
<p>除了手工拖入模块，也可直接在数据清洗列上的文本框中直接修改列名，按回撤提交，可达到同样效果。</p>
<hr />
<h2 id="deletetf">删除该列(DeleteTF)</h2>
<p>删除所在列的内容</p>
<p>删除之后，在该列的内容和所有工具就不再可见。要想修改可以在数据清洗界面左侧的模块列表里选择，修改和删除。</p>
<hr />
<h2 id="joindbtf">数据库匹配(JoinDBTF)</h2>
<p>用于完成与数据库的join操作和匹配，目前测试不完善</p>
<h3 id="ismutlidatas">查询多数据(IsMutliDatas):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>启用该项时，会查询多个满足条件的项，同时将同一列保存为数组</li>
</ul>
<h3 id="searchstrategy">匹配方式(SearchStrategy):</h3>
<ul>
<li>类型:DBSearchStrategy 默认值:Contains</li>
<li>字符串匹配，如like,contains等，符合sql标准语法</li>
</ul>
<h3 id="keyname">表主键(KeyName):</h3>
<ul>
<li>类型:String</li>
<li>字符串匹配，如like,contains等，符合sql标准语法</li>
</ul>
<hr />
<h2 id="repeattf">重复当前值(RepeatTF)</h2>
<p>对当前行进行重复性生成</p>
<h3 id="repeattype">重复模式(RepeatType):</h3>
<ul>
<li>类型:RepeatType 默认值:OneRepeat</li>
<li>没有描述</li>
</ul>
<h3 id="repeatcount">重复次数(RepeatCount):</h3>
<ul>
<li>类型:String 默认值:1</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="responsetf">获取请求响应(ResponseTF)</h2>
<p>使用 网页采集器 获取网页数据，得到响应字段的值并添加到对应的属性中</p>
<h3 id="crawlerselector">爬虫选择(CrawlerSelector):</h3>
<ul>
<li>类型:可编辑选项</li>
<li>填写采集器或模块的名称</li>
</ul>
<h3 id="headerfilter">响应头(HeaderFilter):</h3>
<ul>
<li>类型:String</li>
<li>要获取的响应头的名称，多个之间用空格分割，不区分大小写</li>
</ul>
<hr />
<h2 id="suppliertf">重试补数据(SupplierTF)</h2>
<p>尝试对已有错误日志重跑补数据，错误日志需包含错误所在的任务名和模块名</p>
<h3 id="innerexecute">使用原执行器(InnerExecute):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="time2strtf">时间转字符串(Time2StrTF)</h2>
<p>将时间转换为特定格式的字符串</p>
<h3 id="format">转换格式(Format):</h3>
<ul>
<li>类型:String 默认值:yyyy-MM-dd</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="urlurltf">URL字符转义(UrlTF)</h2>
<p>对超链接url生成URL编码后的字符串，用以进行远程访问</p>
<h3 id="converttype">转换选项(ConvertType):</h3>
<ul>
<li>类型:ConvertType 默认值:Decode</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="htmlhtmltf">HTML字符转义(HtmlTF)</h2>
<p>删除HTML标签和转义符号</p>
<p>当页面包含HTML时，一些字符可能已经被转义了，例如空格成了<code>nsbp%</code>。拖入到对应的列，即可将转义符号恢复为之前的表示</p>
<p>注意:</p>
<ul>
<li>Hawk的Web访问器比python更加智能，默认对带特殊符号和中文的URL进行编码，所以这个模块用的并不多。</li>
</ul>
<h3 id="converttype_1">转换选项(ConvertType):</h3>
<ul>
<li>类型:ConvertType 默认值:Decode</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="regexsplittf">正则分割(RegexSplitTF)</h2>
<p>使用正则表达式分割字符串</p>
<h3 id="fromback">倒序(FromBack):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>勾选此项后，选择从后数的第n项</li>
</ul>
<h3 id="ismanydata">工作模式(IsManyData):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:One
*</li>
</ul>
<h3 id="_9">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_10">单文档</h3>
<p>单文档</p>
<h3 id="_11">不进行转换</h3>
<h3 id="index">匹配编号(Index):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>当值小于0时，可同时匹配多个值</li>
</ul>
<h3 id="script">表达式(Script):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="mergetf">合并多列(MergeTF)</h2>
<p>该模块可以将多个列合并成一个列</p>
<p>常见的如将page合并到url中，也可以通过文件名，合并出要保存的文件的位置，是使用次数最多的模块。</p>
<p>它的操作非常灵活，例如格式为： <code>format= {0}+{1}+{2}</code> ， 其他列为<code>B C</code>，则代表将输入列，B列和C列的内容直接拼接。</p>
<ul>
<li><code>{0}</code>：输入列,</li>
<li><code>{1}</code>：<code>其他列</code>中的第0项，<code>{1}</code>代表第1项</li>
<li><code>[a]</code>：A列中的内容</li>
<li><code>{config}</code> : 工程全局配置中键为config的值</li>
</ul>
<p>总结来说： 方括号代表从本行的其他列，大括号可从全局配置中读取内容
若全局配置或数据中不包含对应的内容，则该列自动为空</p>
<h3 id="mergewith">其他项(MergeWith):</h3>
<ul>
<li>类型:String</li>
<li>写入多个列名，中间使用空格分割，若合并输入列，则可以为空</li>
</ul>
<h3 id="format_1">格式(Format):</h3>
<ul>
<li>类型:String</li>
<li>形如'http:\{0}:{1},{2}...' - 输入列的序号为0， - 之后的1,2分别代表【其他项】的第0和第1个值</li>
</ul>
<h3 id="referformat">参考格式(ReferFormat):</h3>
<ul>
<li>类型:string选项</li>
<li>为了方便用户，下拉菜单中提供了已有 网页采集器 配置的url，可修改后使用</li>
</ul>
<hr />
<h2 id="pythonpythontf">Python转换器(PythonTF)</h2>
<p>执行特定的python代码或脚本，最后一行需要为值类型，作为该列的返回值
例如，有两列a和b, 要将它们按字符串相加:</p>
<p><code>a+b</code>
若希望按数值类型相加， 则需要提前将其转换</p>
<p><code>float(a)+float(b)</code>
也可以提前定义函数:</p>
<pre><code>def add(x,y):
return float(x)+float(y)
add(a,b)
</code></pre>

<p>也可以使用lambda:</p>
<pre><code>f= lambda a,b: a+b
f(a,b)
</code></pre>

<h3 id="_12">注意：</h3>
<ol>
<li>你可以在文本框中定义函数，但不建议太过复杂</li>
<li>很难引入第三方库，这受限于C#使用的ironpython(一个C#和Python交互的模块)的功能, Hawk3中引入了调用第三方库的功能，通过编写库路径，从而能够在脚本中import库，但功能支持并不好。</li>
<li>不论操作如何，脚本的最后一行需要是个可求值的元素，传递给对应的列，比如</li>
<li><code>return a</code> #这是错误的</li>
<li><code>a+b</code> 正确，可求值</li>
<li><code>lambda x:x+1</code>  你确定要返回一个函数或lambda?肯定也是不对的</li>
<li>Hawk并不预定义每个列具体的类型，因此需要在Python代码中对其进行类型和是否为空的判断。</li>
</ol>
<h3 id="scriptworkmode">工作模式(ScriptWorkMode):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:NoTransform
*</li>
</ul>
<h3 id="_13">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_14">单文档</h3>
<p>单文档</p>
<h3 id="_15">不进行转换</h3>
<h3 id="script_1">执行脚本(Script):</h3>
<ul>
<li>类型:String 默认值:value</li>
<li>没有描述</li>
</ul>
<h3 id="pythonlibrarypath">Python库路径(LibraryPath):</h3>
<ul>
<li>类型:String</li>
<li>若需要引用第三方Python库，则可指定库的路径，一行一条</li>
</ul>
<hr />
<h2 id="rereplacetf">正则替换(ReReplaceTF)</h2>
<p>通过正则表达式替换数值</p>
<h3 id="replacetext">替换为(ReplaceText):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="ismanydata_1">工作模式(IsManyData):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:One
*</li>
</ul>
<h3 id="_16">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_17">单文档</h3>
<p>单文档</p>
<h3 id="_18">不进行转换</h3>
<h3 id="index_1">匹配编号(Index):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>当值小于0时，可同时匹配多个值</li>
</ul>
<h3 id="script_2">表达式(Script):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="regextf">正则转换器(RegexTF)</h2>
<p>通过正则表达式提取内容, 可匹配一个和多个内容
设置匹配编号为正数n时，它可将第n个匹配结果转换到新列上。如果不填写新列名，则内容直接覆盖原始列。
输入负数n时，则会返回倒数第n个内容。如果没有发现匹配，则返回空</p>
<h3 id="ismanydata_2">工作模式(IsManyData):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:One
*</li>
</ul>
<h3 id="_19">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_20">单文档</h3>
<p>单文档</p>
<h3 id="_21">不进行转换</h3>
<h3 id="index_2">匹配编号(Index):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>当值小于0时，可同时匹配多个值</li>
</ul>
<h3 id="script_3">表达式(Script):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="numbertf">提取数字(NumberTF)</h2>
<p>提取当前列中出现的数值</p>
<p>它是正则转换器的特例，它能够提取浮点或整数，也能包含正负数</p>
<h3 id="ismanydata_3">工作模式(IsManyData):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:One
*</li>
</ul>
<h3 id="_22">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_23">单文档</h3>
<p>单文档</p>
<h3 id="_24">不进行转换</h3>
<h3 id="index_3">匹配编号(Index):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>当值小于0时，可同时匹配多个值</li>
</ul>
<h3 id="script_4">表达式(Script):</h3>
<ul>
<li>类型:String 默认值:(-?\d+)(.\d+)?</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="strextracttf">字符首尾抽取(StrExtractTF)</h2>
<p>提取字符串中，从首串到尾串中间的文本内容</p>
<p>当文本为<code>CABD</code>时，需要获取B，而B非常长，写正则表达式提取有很大困难时，可以使用本模块。此时，首串填写A，尾串填写D，则Hawk就能将B提取出来。如果勾选<code>包含首尾字符</code>，则输出<code>ABD</code>，否则只有B。注意:</p>
<ul>
<li>建议A和D在文本中是唯一的，否则抽取出来的B可能并不是你想要的。</li>
<li>该工具特别适合在抽取网页的某一特定内容时使用.</li>
</ul>
<h3 id="former">首串(Former):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="end">尾串(End):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="havestartend">包含首尾串(HaveStartEnd):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>返回的结果里是否包含首串和尾串</li>
</ul>
<hr />
<h2 id="tolisttf">启动并行(ToListTF)</h2>
<p>可设置任务并行方式和参数</p>
<p>该模块在执行时，会切分本模块前后的数据流，以前侧的数据为种子，后侧的任务为mapper执行.</p>
<p>子线程名称和子线程数量，都支持直接写值，或使用方括号表达式来获取别的列的内容。</p>
<p>例如，如果你确定每个子任务都会获取100条数据，就可以在<code>子线程数量</code>中填写<code>100</code>，之后当该任务获取了50个元素时，进度条正好处在50%的位置。如果有一列名为“小区名”， 则可以在<code>子线程名称</code>栏目中填写<code>[小区名]</code> ，Hawk就会把小区名列中的内容作为子任务的名称。</p>
<p>注意:</p>
<ol>
<li>该转换器在调试和串行执行模式不起任何作用，仅仅作为一个标志</li>
<li>它能够在并行模式下，给执行引擎一个并行分叉的标志。</li>
</ol>
<h3 id="mountcolumn">子线程数量(MountColumn):</h3>
<ul>
<li>类型:String</li>
<li>每个子线程将要获取的数量，用于显示进度条，可不填</li>
</ul>
<h3 id="groupmount">分组并行数量(GroupMount):</h3>
<ul>
<li>类型:Int32 默认值:1</li>
<li>将多个种子合并为一个任务执行，这对于小型种子任务可有效提升效率</li>
</ul>
<h3 id="displayprogress">显示独立任务(DisplayProgress):</h3>
<ul>
<li>类型:Boolean 默认值:True</li>
<li>是否将每个子线程插入到任务队列中，从而显示进度</li>
</ul>
<hr />
<h2 id="trimtf">清除空白符(TrimTF)</h2>
<p>清除字符串前后和中间的空白符
默认能去掉文本前后的空白字符，也可以通过勾选内部选项，清除文本中间的空白符
注意：</p>
<ul>
<li>使用<code>正则替换</code>也能实现类似的要求，只是本模块会更简单。</li>
</ul>
<h3 id="replaceblank">清除中间空格(ReplaceBlank):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>没有描述</li>
</ul>
<h3 id="replaceinnerblank">空白符替换为空格(ReplaceInnerBlank):</h3>
<ul>
<li>类型:Boolean 默认值:True</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="fileexistft">路径是否存在(FileExistFT)</h2>
<p>判断某一个文件是否已经在指定路径上</p>
<hr />
<h2 id="mergerepeattf">重复项合并(MergeRepeatTF)</h2>
<p>对重复的数据行，进行合并操作</p>
<h3 id="islazylinq">延迟输出(IsLazyLinq):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>不勾选此选项使用枚举式迭代，需保证在本模块之后没有其他操作，否则请勾选该选项</li>
</ul>
<h3 id="collectioncolumns">合并到集合的属性(CollectionColumns):</h3>
<ul>
<li>类型:String</li>
<li>填入空格分割的列名，对本模块所在列的值相同的所有属性分别进行纵向合并数组</li>
</ul>
<h3 id="sumcolumns">求和属性(SumColumns):</h3>
<ul>
<li>类型:String</li>
<li>可填入空格分割的多个列名 对本模块所在列的值相同的所有属性，分别进行按列求和</li>
</ul>
<hr />
<h2 id="dicttf">矩阵转置(DictTF)</h2>
<p>将列数据转换为行数据，拖入的列为key</p>
<hr />
<h2 id="-etltf">子任务-转换(EtlTF)</h2>
<p>调用所选的子任务作为转换器，有关子任务，请参考相关文档</p>
<h3 id="iscycle">递归到下列(IsCycle):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>没有描述</li>
</ul>
<h3 id="ismanydata_4">工作模式(IsManyData):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:List
*</li>
</ul>
<h3 id="_25">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_26">单文档</h3>
<p>单文档</p>
<h3 id="_27">不进行转换</h3>
<h3 id="-etlselector">子任务-选择(ETLSelector):</h3>
<ul>
<li>类型:可编辑选项</li>
<li>输入或选择调用的子任务的名称</li>
</ul>
<h3 id="etlrange">调用范围(ETLRange):</h3>
<ul>
<li>类型:String</li>
<li>设定调用子任务的模块范围，例如2:30表示被调用任务的第2个到第30个子模块将会启用，其他模块忽略，2:-1表示从第2个到倒数第二个启用，符合python的slice语法，为空则默认全部调用</li>
</ul>
<h3 id="mappingset">属性映射(MappingSet):</h3>
<ul>
<li>类型:String</li>
<li>源属性:目标属性列 多个映射中间用空格分割，例如A:B C:D, 表示主任务中的A,B属性列会以C,D的名称传递到子任务中</li>
</ul>
<hr />
<h2 id="xpathxpathtf">XPath转换器(XPathTF)</h2>
<p>通过XPath或CSS选取html中的子节点文档</p>
<p>当输入的单元格内容为html文档，而又想提取其部分数据，用 网页采集器 又<code>杀鸡用牛刀</code>，则可以考虑使用它。</p>
<h3 id="xpath">XPath</h3>
<p>关于XPath语法，可参考<a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp">教程</a></p>
<p>XPath可以非常灵活，例如：</p>
<ul>
<li>bookstore 选取 bookstore 元素的所有子节点。</li>
<li>/bookstore    选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</li>
<li>bookstore/book    选取属于 bookstore 的子元素的所有 book 元素。</li>
<li>//book    选取所有 book 子元素，而不管它们在文档中的位置。</li>
<li>bookstore//book   选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</li>
<li>//@lang   选取名为 lang 的所有属性。</li>
<li>//@src 可匹配所有src标签</li>
<li>//title[@lang] 选取所有拥有名为 lang 的属性的 title 元素
还可以通过<code>|</code>对多个表达式进行混合，Hawk支持了完整的XPath语法，因此不论是<code>网页采集器</code>以及数据清洗的<code>XPath</code>转换器，都能极其灵活地实现各种需求。</li>
</ul>
<h3 id="cssselector">CSSSelector</h3>
<p>多数情况下，使用XPath就能解决问题，但是CSSSelector更简洁，且鲁棒性更强。关于它的介绍，可<a href="http://www.w3school.com.cn/cssref/css_selectors.asp">参考教程</a>
当然，大部分情况不需要那么复杂，只要记住以下几点：</p>
<ul>
<li><code>.name</code> 获取所有id为name的元素</li>
<li><code>#name</code> 获取所有class为name的元素</li>
<li><code>p</code> 获取所有p元素</li>
<li><code>ul &gt; li</code> 获取所有父节点是ul的li元素</li>
</ul>
<h3 id="xpath_1">路径(XPath):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="ismanydata_5">工作模式(IsManyData):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:One
*</li>
</ul>
<h3 id="_28">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_29">单文档</h3>
<p>单文档</p>
<h3 id="_30">不进行转换</h3>
<h3 id="gettext">获取正文(GetText):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>勾选此项后，会智能提取新闻正文，XPath路径可为空</li>
</ul>
<h3 id="selectorformat">选择器(SelectorFormat):</h3>
<ul>
<li>类型:SelectorFormat 默认值:XPath
*</li>
</ul>
<h3 id="crawltype">抓取目标(CrawlType):</h3>
<ul>
<li>类型:CrawlType 默认值:InnerText
*</li>
</ul>
<hr />
<h2 id="xpathtf2">门类枚举(XPathTF2)</h2>
<p>要拖入HTML文本列,可将页面中的门类，用Cross模式组合起来，适合于爬虫无法抓取全部页面，但可以按分类抓取的情况。需调用 网页采集器 ，具体参考文档-XPathTF2</p>
<h3 id="crawlerselector_1">爬虫选择(CrawlerSelector):</h3>
<ul>
<li>类型:可编辑选项</li>
<li>填写采集器或模块的名称</li>
</ul>
<hr />
<h2 id="splittf">字符串分割(SplitTF)</h2>
<p>通过字符分割字符串</p>
<h3 id="shouldsplitchars">按字符直接分割(ShouldSplitChars):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>将原文本每个字符直接分割开</li>
</ul>
<h3 id="splitpause">空格分割(SplitPause):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>没有描述</li>
</ul>
<h3 id="index_4">匹配编号(Index):</h3>
<ul>
<li>类型:String 默认值:0
*</li>
<li>若想获取分割后的第0个元素，则填入0，获取倒数第一个元素，则填入-1</li>
<li>可输入多个匹配编号，中间以空格分割，</li>
<li>【输出列】也需要与之一对应</li>
</ul>
<h3 id="splitchar">分割字符(SplitChar):</h3>
<ul>
<li>类型:String</li>
<li>多个分隔符用空格分割，换行符用\t，制表符用\t</li>
</ul>
<hr />
<h1 id="_31">常用</h1>
<h2 id="crawlertf">从爬虫转换(CrawlerTF)</h2>
<p>使用 网页采集器 获取网页数据，拖入的列需要为超链接</p>
<h3 id="get">一般的get请求</h3>
<p>一般情况下, 将从爬虫转换拖入到对应的URL列中，通过下拉菜单选择要调用的爬虫名称，即可完成所有的配置：</p>
<p>![请求设置][http://static.zybuluo.com/buptzym/hgwpmxsjz0gun5epqt2087wh/image_1avc2t94d3l51sofkah8m1lrrm.png]</p>
<p>本模块是沟通网页采集器和数据清洗的桥梁。本质上说，网页采集器是针对获取网页而特别定制的<code>数据清洗模块</code>。</p>
<p>你需要填写<code>爬虫选择</code>，告诉它要调用哪个采集器。注意：</p>
<ul>
<li>早期版本的Hawk,会默认选择在<code>算法模块</code>的第一个网页采集器，但实践证明这样会导致问题，后来就取消了功能。</li>
</ul>
<h3 id="post">实现post请求</h3>
<p>web请求中，有两种主要的请求类型:post和get。 使用POST能支持传输更多的数据。更多的细节，可以参考http协议的相关文档，网上汗牛充栋，这里就不多说了。</p>
<p>post请求时，Hawk要给服务器需要传递两个参数：url 和post。一般来说，在执行post请求时，url是稳定的，post值是动态改变的。</p>
<p>首先要配置调用的网页采集器为<code>post</code>模式（打开网页采集器，请求详情，模式-&gt;下拉菜单）。</p>
<p>之后，需要将<code>从爬虫转换</code>拖到要调用的url列上。如果没有url列，可以通过<code>添加新列</code>，生成要访问的url列。</p>
<p>之后，我们要将post数据传递到网页采集器中。你总是可以通过<code>合并多列</code>拼接或各种手段，生成要Post的数据列。之后，可以在<code>从爬虫转换</code>中的<code>post数据</code>中，填写<code>[post列]</code>， 而<code>post列</code>就是包含post数据的列名。 注意：</p>
<ul>
<li>Hawk使用方括号语法，来引用其他列的值作为当前的参数</li>
</ul>
<h3 id="postpostdata">Post数据(PostData):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="proxy">代理配置(Proxy):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="crawlerselector_2">爬虫选择(CrawlerSelector):</h3>
<ul>
<li>类型:可编辑选项</li>
<li>填写采集器或模块的名称</li>
</ul>
<hr />
<h2 id="splitpagetf">分页(SplitPageTF)</h2>
<p>根据总页数和每页数量进行分页操作，拖入列为总页数。 相比于使用Python转换器，可极大地简化操作。注意：</p>
<ul>
<li>早期版本的Hawk中，若希望对网页进行分页，需要拖入多个模块才能实现，非常繁琐。</li>
<li>本模块在输入数量数，每页数量和起始值之后，即可自动创建步进整数。</li>
<li>例如总数量270, 每页数量为20，起始值为1，则生成的列为1，2，3..14</li>
</ul>
<h3 id="minvalue">最小值(MinValue):</h3>
<ul>
<li>类型:String 默认值:1</li>
<li>除了直接填写数值，还可通过方括号表达式从其他列传入</li>
</ul>
<h3 id="itemperpage">每页数量(ItemPerPage):</h3>
<ul>
<li>类型:String 默认值:1</li>
<li>除了直接填写数值，还可通过方括号表达式从其他列传入</li>
</ul>
<hr />
<h2 id="jsonjsontf">转换为Json(JsonTF)</h2>
<p>从字符串转换为json（数组或字典类型）</p>
<p>当输入字符串是Json时，可以通过Json转换器将文本转换为Json。其工作模式和Python转换器一样，此处不赘述。</p>
<p>json转换器的转换结果，实际上是一个动态类型的python对象。例如如下json:</p>
<pre><code>{
'key':[{}{}{}]
'value':
{
'key1':value
'key2':value
}
}
</code></pre>

<p>拖入json转换器到该列，如果工作模式是<code>不进行转换</code>，则你可以在转换结果列，拖入<code>Python转换器</code>,脚本内容填写<code>data[key]</code>,工作模式选择<code>转换为列表</code>，则key中的数组自动会被提取出来。</p>
<p>注意事项:</p>
<ol>
<li>python和json转换器配合使用，能够解决一大类ajax网页的问题。更详细的内容，可参考</li>
<li>网页的json格式并不标准，此时需要通过其他工具，对字符串进行预处理，方可转换为json。</li>
<li>如果json非常复杂，是不建议直接用Hawk做数据清洗的，正确的做法是将json保存成文本，之后用其他工具或手工编写代码后处理。</li>
</ol>
<h3 id="scriptworkmode_1">工作模式(ScriptWorkMode):</h3>
<ul>
<li>类型:ScriptWorkMode 默认值:NoTransform
*</li>
</ul>
<h3 id="_32">多文档</h3>
<p>生成多条数据（文档）</p>
<h3 id="_33">单文档</h3>
<p>单文档</p>
<h3 id="_34">不进行转换</h3>
<hr />
<h2 id="delaytf">延时(DelayTF)</h2>
<p>在工作流中插入延时，可休眠固定长度避免爬虫被封禁，单位为ms</p>
<p>在不同的位置插入延时有不同的行为，例如在模块A之前插入延时，则A模块每次执行前都会延时固定长度。
除了拖入延时，在<code>串行模式</code>下填入延时时间，则会在每个web请求前插入指定的延时，更加方便。</p>
<h3 id="delaytime">延时值(DelayTime):</h3>
<ul>
<li>类型:String</li>
<li>单位为毫秒，也可使用方括号语法，例如[a]表示从a列中读取延时长度</li>
</ul>
<hr />
<h2 id="-etlex">子任务-执行(EtlEX)</h2>
<p>调用其他任务，作为执行器，一般位于任务的末尾。</p>
<p>子任务是Hawk中高级但却非常重要的功能，可以实现例如多级跳转，采集详情页等等的功能，非常强大。
所谓<code>子任务</code>，就是能先构造出一个任务，然后被其他任务调用。被调用的任务就是子任务。我们应该能够了解子任务其实就是函数，可以定义输入列和输出列，把整个子任务看成一个模块，从而方便重用。</p>
<p>使用子任务-执行的例子： 先设计构造获取某个页面全部图片的任务， 并创建主任务，在主任务中调用刚才创建的子任务。</p>
<h3 id="addtask">添加到任务(AddTask):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>勾选后，本子任务会添加到任务管理器中</li>
</ul>
<h3 id="-etlselector_1">子任务-选择(ETLSelector):</h3>
<ul>
<li>类型:可编辑选项</li>
<li>输入或选择调用的子任务的名称</li>
</ul>
<h3 id="etlrange_1">调用范围(ETLRange):</h3>
<ul>
<li>类型:String</li>
<li>设定调用子任务的模块范围，例如2:30表示被调用任务的第2个到第30个子模块将会启用，其他模块忽略，2:-1表示从第2个到倒数第二个启用，符合python的slice语法，为空则默认全部调用</li>
</ul>
<h3 id="mappingset_1">属性映射(MappingSet):</h3>
<ul>
<li>类型:String</li>
<li>源属性:目标属性列 多个映射中间用空格分割，例如A:B C:D, 表示主任务中的A,B属性列会以C,D的名称传递到子任务中</li>
</ul>
<hr />
<h1 id="_35">过滤器</h1>
<h2 id="nullft">空对象过滤器(NullFT)</h2>
<p>检查文本是否为空白符或null，常用</p>
<p>可以过滤掉所有内容为空，或字符串全部都是空字符的情况</p>
<h3 id="revert">求反(Revert):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>将结果取反后返回
例如筛选器判断为<code>正确</code>，则返回错误</li>
</ul>
<h3 id="isdebugfilter">调试时启用(IsDebugFilter):</h3>
<ul>
<li>类型:Boolean 默认值:True</li>
<li>没有描述</li>
</ul>
<h3 id="filterworkmode">过滤模式(FilterWorkMode):</h3>
<ul>
<li>类型:FilterWorkMode 默认值:ByItem</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="rangeft">数值范围过滤器(RangeFT)</h2>
<p>从数值列中筛选出从最小值到最大值范围的文档</p>
<p>可以填写最大值和最小值，只有本列的值处在该范围内的文档可被留下。若该单元格的内容不是数字，则会被忽略。</p>
<h3 id="max">最大值(Max):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="min">最小值(Min):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="revert_1">求反(Revert):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>将结果取反后返回
例如筛选器判断为<code>正确</code>，则返回错误</li>
</ul>
<h3 id="isdebugfilter_1">调试时启用(IsDebugFilter):</h3>
<ul>
<li>类型:Boolean 默认值:True</li>
<li>没有描述</li>
</ul>
<h3 id="filterworkmode_1">过滤模式(FilterWorkMode):</h3>
<ul>
<li>类型:FilterWorkMode 默认值:ByItem</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="regexft">正则筛选器(RegexFT)</h2>
<p>编写正则表达式来过滤文本</p>
<p>需要列名，输入正则表达式，和其最小匹配的内容数量，即可过滤内容。
有关正则表达式，可参考<a href="https://www.jb51.net/tools/zhengze.html">这里</a></p>
<h3 id="script_5">表达式(Script):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="count">最小匹配数(Count):</h3>
<ul>
<li>类型:Int32 默认值:1</li>
<li>只有正则表达式匹配该文本的结果数量大于等于该值时，才会保留，默认为1</li>
</ul>
<h3 id="revert_2">求反(Revert):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>将结果取反后返回
例如筛选器判断为<code>正确</code>，则返回错误</li>
</ul>
<h3 id="isdebugfilter_2">调试时启用(IsDebugFilter):</h3>
<ul>
<li>类型:Boolean 默认值:True</li>
<li>没有描述</li>
</ul>
<h3 id="filterworkmode_2">过滤模式(FilterWorkMode):</h3>
<ul>
<li>类型:FilterWorkMode 默认值:ByItem</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="repeatft">删除重复项(RepeatFT)</h2>
<p>以拖入的列为唯一主键，按行进行去重，仅保留重复出现的第一项</p>
<h3 id="revert_3">求反(Revert):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>将结果取反后返回
例如筛选器判断为<code>正确</code>，则返回错误</li>
</ul>
<h3 id="isdebugfilter_3">调试时启用(IsDebugFilter):</h3>
<ul>
<li>类型:Boolean 默认值:True</li>
<li>没有描述</li>
</ul>
<h3 id="filterworkmode_3">过滤模式(FilterWorkMode):</h3>
<ul>
<li>类型:FilterWorkMode 默认值:ByItem</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="numrangeft">数量范围选择(NumRangeFT)</h2>
<p>选择一定数量的行，如跳过前100行，再选取50条</p>
<p>不需要列名，它可以跳过并选择部分文档，类似于sql语句中的skip和limit关键字。
注意:</p>
<ul>
<li>当skip数量过大，而目标数据是延迟执行时，skip会需要相当长的时间，而任务进度条没有任何反应，因此尽量避免这种设计</li>
</ul>
<h3 id="skip">跳过(Skip):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>没有描述</li>
</ul>
<h3 id="take">获取(Take):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>没有描述</li>
</ul>
<h3 id="revert_4">求反(Revert):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>将结果取反后返回
例如筛选器判断为<code>正确</code>，则返回错误</li>
</ul>
<h3 id="isdebugfilter_4">调试时启用(IsDebugFilter):</h3>
<ul>
<li>类型:Boolean 默认值:True</li>
<li>没有描述</li>
</ul>
<h3 id="filterworkmode_4">过滤模式(FilterWorkMode):</h3>
<ul>
<li>类型:FilterWorkMode 默认值:ByItem</li>
<li>没有描述</li>
</ul>
<hr />
<h1 id="_36">执行器</h1>
<h2 id="dbex">写入数据库(DbEX)</h2>
<p>进行数据库操作，包括写入，删除和更新，输入列为表的主键</p>
<h3 id="executetype">操作类型(ExecuteType):</h3>
<ul>
<li>类型:EntityExecuteType 默认值:OnlyInsert</li>
<li>选择数据库的操作，如插入，删除，更新等</li>
</ul>
<h3 id="tablenames">表名(TableNames):</h3>
<ul>
<li>类型:可编辑选项
*
必填，若数据库不存在该表，则会根据第一条数据的列自动创建表
不符合数据库要求的列名会被替换</li>
</ul>
<hr />
<h2 id="savefileex">保存超链接文件(SaveFileEX)</h2>
<p>保存对应链接的文件，如图片，视频等
拖入的列为文件的超链接地址
<code>保存位置</code>:可以使用方括号表达式，将某一列的内容传递过来
注意:</p>
<ul>
<li>一些网站必须要求登录以后才能下载内容。而如果你已经配置好能正常访问该网站的<code>网页采集器</code>，那么就可以在<code>共用采集器名</code>中填写这个采集器的名称，此时本模块会使用那个采集器的header进行抓取。</li>
</ul>
<h3 id="savepath">保存位置(SavePath):</h3>
<ul>
<li>类型:String
*
路径或文件名，例如D:\file.txt, 可通过'[]'引用其他列，
若为目录名，必须显式以/结束，文件名将会通过url自动解析</li>
</ul>
<h3 id="crawlerselector_3">爬虫选择(CrawlerSelector):</h3>
<ul>
<li>类型:可编辑选项</li>
<li>填写采集器或模块的名称</li>
</ul>
<h3 id="isasync">是否异步(IsAsync):</h3>
<ul>
<li>类型:Boolean 默认值:False</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="tableex">写入数据表(TableEX)</h2>
<p>将数据保存至软件的数据管理器中，之后可方便进行其他处理，拖入到任意一列皆可，常用</p>
<h3 id="table">表名(Table):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="writefiletexttf">写入文件文本(WriteFileTextTF)</h2>
<p>写入文件中的文本，由于在并行模式下同时写入文件可能会导致问题，因此尽量使用串行模式</p>
<h3 id="filename">路径(FileName):</h3>
<ul>
<li>类型:String</li>
<li>例如d:\test\mydb.sqlite</li>
</ul>
<h3 id="encodingtype">编码(EncodingType):</h3>
<ul>
<li>类型:EncodingType 默认值:UTF8</li>
<li>没有描述</li>
</ul>
<hr />
<h1 id="_37">生成器</h1>
<h2 id="daterangege">生成区间时间(DateRangeGE)</h2>
<p>生成某范围内的日期和时间</p>
<h3 id="minvalue_1">最小值(MinValue):</h3>
<ul>
<li>类型:String 默认值:2018-10-08 22:25:41:6985</li>
<li>按类似yyyy-MM-dd HH:mm:ss:ffff格式进行填写</li>
</ul>
<h3 id="maxvalue">最大值(MaxValue):</h3>
<ul>
<li>类型:String 默认值:2018-10-11 22:25:41:6985</li>
<li>按类似yyyy-MM-dd HH:mm:ss:ffff格式进行填写</li>
</ul>
<h3 id="interval">间隔(Interval):</h3>
<ul>
<li>类型:String 默认值:1h 0m 0s</li>
<li>按类似1'h '3'm '5's'格式进行填写</li>
</ul>
<h3 id="format_2">生成时间格式(Format):</h3>
<ul>
<li>
<p>类型:String 默认值:yyyy-MM-dd HH:mm:ss:ffff
*
可参考C# DateTime Format相关方法，以下是一些例子：</p>
</li>
<li>
<p>yyyy-MM-dd等</p>
</li>
<li>yyyy-MM</li>
</ul>
<h3 id="mergetype">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="readfiletextge">读取文件文本(ReadFileTextGE)</h2>
<p>获取文件中的全部纯文本内容</p>
<p>注意与【读取文件数据】区别，后者为一行一条数据，前者则将所有文本（包括换行符）都看为一条数据</p>
<h3 id="filename_1">路径(FileName):</h3>
<ul>
<li>类型:String</li>
<li>例如d:\test\mydb.sqlite</li>
</ul>
<h3 id="encodingtype_1">编码(EncodingType):</h3>
<ul>
<li>类型:EncodingType 默认值:UTF8</li>
<li>没有描述</li>
</ul>
<h3 id="mergetype_1">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="readfilege">读取文件数据(ReadFileGe)</h2>
<p>从文件中读取数据内容，为了保证正确读取，需配置文件格式和读取属性
除了一般的数据库导入导出，Hawk还支持从文件导入，支持的文件类型包括：</p>
<ul>
<li>Excel</li>
<li>CSV(逗号分割文本文件)</li>
<li>TXT (制表符分割文本文件)</li>
<li>Json</li>
<li>xml</li>
</ul>
<h3 id="filename_2">路径(FileName):</h3>
<ul>
<li>类型:String</li>
<li>例如d:\test\mydb.sqlite</li>
</ul>
<h3 id="mergetype_2">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="folderge">获取文件夹文件(FolderGE)</h2>
<p>获取文件夹下的所有文件，拖入列为文件夹的名称</p>
<p>可直接对文件名的筛选</p>
<h3 id="folderpath">路径(FolderPath):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="pattern">筛选模式(Pattern):</h3>
<ul>
<li>类型:String 默认值:<em>.</em></li>
<li>符合windows的文件通配符筛选规范</li>
</ul>
<h3 id="searchoption">是否递归(SearchOption):</h3>
<ul>
<li>类型:SearchOption 默认值:TopDirectoryOnly</li>
<li>即是否获取子文件夹的子文件</li>
</ul>
<h3 id="mergetype_3">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="dbge">从数据库生成(DbGE)</h2>
<p>从数据库读取内容，需提前在<code>数据视图</code>中新建或配置连接</p>
<h3 id="2tablenames">2.操作表名(TableNames):</h3>
<ul>
<li>类型:string选项</li>
<li>没有描述</li>
</ul>
<h3 id="3mount">3.数量(Mount):</h3>
<ul>
<li>类型:Int32 默认值:-1</li>
<li>没有描述</li>
</ul>
<h3 id="mergetype_4">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="randomge">生成随机数(RandomGE)</h2>
<p>生成某范围内和指定数量的随机数</p>
<h3 id="minvalue_2">最小值(MinValue):</h3>
<ul>
<li>类型:String 默认值:1</li>
<li>没有描述</li>
</ul>
<h3 id="maxvalue_1">最大值(MaxValue):</h3>
<ul>
<li>类型:String 默认值:100</li>
<li>没有描述</li>
</ul>
<h3 id="count_1">数量(Count):</h3>
<ul>
<li>类型:String 默认值:100</li>
<li>没有描述</li>
</ul>
<h3 id="mergetype_5">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="rangege">生成区间数(RangeGE)</h2>
<p>生成某范围内的数值
例如生成从0到100，步进为1的值即为1,2,3..100</p>
<h3 id="minvalue_3">最小值(MinValue):</h3>
<ul>
<li>类型:String 默认值:1</li>
<li>没有描述</li>
</ul>
<h3 id="maxvalue_2">最大值(MaxValue):</h3>
<ul>
<li>类型:String 默认值:1</li>
<li>除了填写数字，还可以用方括号表达式，如[a]表示从a列获取值作为本参数的真实值</li>
</ul>
<h3 id="interval_1">间隔(Interval):</h3>
<ul>
<li>类型:String 默认值:1</li>
<li>如需生成数组1,3,5,7,9，则间隔为2</li>
</ul>
<h3 id="mergetype_6">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="tablege">从数据表生成(TableGE)</h2>
<p>从数据管理中已有的数据表中生成，常用</p>
<h3 id="tableselector">数据表(TableSelector):</h3>
<ul>
<li>类型:string选项</li>
<li>选择所要连接的数据表</li>
</ul>
<h3 id="mergetype_7">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="textge">从文本生成(TextGE)</h2>
<p>每行一条数据，常用</p>
<h3 id="content">文本(Content):</h3>
<ul>
<li>类型:String</li>
<li>每行一条</li>
</ul>
<h3 id="mergetype_8">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="bfsge">请求队列(BfsGE)</h2>
<h3 id="bfsstarturl">BFS起始位置(StartURL):</h3>
<ul>
<li>类型:String</li>
<li>没有描述</li>
</ul>
<h3 id="delaytime_1">延时时间(DelayTime):</h3>
<ul>
<li>类型:Int32 默认值:0</li>
<li>没有描述</li>
</ul>
<h3 id="mergetype_9">工作模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Cross</li>
<li>没有描述</li>
</ul>
<hr />
<h2 id="-etlge">子任务-生成(EtlGE)</h2>
<p>调用其他任务作为生成器，使用类似于“生成区间数”</p>
<h3 id="mergetype_10">生成模式(MergeType):</h3>
<ul>
<li>类型:MergeType 默认值:Append</li>
<li>没有描述</li>
</ul>
<h3 id="-etlselector_2">子任务-选择(ETLSelector):</h3>
<ul>
<li>类型:可编辑选项</li>
<li>输入或选择调用的子任务的名称</li>
</ul>
<h3 id="etlrange_2">调用范围(ETLRange):</h3>
<ul>
<li>类型:String</li>
<li>设定调用子任务的模块范围，例如2:30表示被调用任务的第2个到第30个子模块将会启用，其他模块忽略，2:-1表示从第2个到倒数第二个启用，符合python的slice语法，为空则默认全部调用</li>
</ul>
<h3 id="mappingset_2">属性映射(MappingSet):</h3>
<ul>
<li>类型:String</li>
<li>源属性:目标属性列 多个映射中间用空格分割，例如A:B C:D, 表示主任务中的A,B属性列会以C,D的名称传递到子任务中</li>
</ul>
<hr />
<h1 id="_38">子任务引擎</h1>
<p>（早期版本的Hawk称之为子流程，为了简化概念，使用<code>子任务</code>这一说法，下同）</p>
<h2 id="1_5">1.基本概念</h2>
<p>当流程设计的越来越复杂，越来越长时，就难以进行管理了。因此，采用模块化的设计才会更加合理。本节我们介绍子任务的原理和使用。</p>
<p>子任务是Hawk中高级但却非常重要的功能，可以实现例如多级跳转，采集详情页等等的功能，非常强大。</p>
<p>所谓<code>子任务</code>，就是能先构造出一个任务，然后被其他任务调用。被调用的任务就是子任务。我们应该能够了解子任务其实就是函数，可以定义输入列和输出列，把整个子任务看成一个模块，从而方便重用。</p>
<p>子任务的功能包含以下三类：</p>
<ul>
<li>子任务-生成，作为生成器，一般在主任务的开头位置，行为和生成器一致。</li>
<li>如生成全国城市列表的流</li>
<li>生成某个网站全部分类的流</li>
<li>子任务-转换: 可看成转换器，通常位于任务中间位置</li>
<li>通过输入url地址，就能转换出该页面中所有需要信息的流</li>
<li>子任务-执行: 作为执行器，一般位于末尾。</li>
<li>例如可以构造获取某个页面所有图片的执行流</li>
</ul>
<p>为什么不包括子任务-过滤？因为过滤操作通常比较简单，不需要子任务实现。</p>
<h2 id="2_4">2.参数设置</h2>
<p>子任务可以分为两部分：参数部分和执行部分。在本例中，子任务中的第一个<code>从文本生成</code>，只是参数，目的是为了子任务设计器能构成输出数据的完整流程。但要想被别的模块调用，则只应该有执行部分。而参数部分，需要主任务传递给子任务。这就是<code>调用范围</code>的意义，它能将主任务的指定参数传递到子任务上，成为子任务的一部分。</p>
<p>举例子，如果一个长度为20个模块的子任务，前两个模块为参数部分，后18个是执行部分，因此调用范围可以写2:18（从0开始）。 当然为了方便，你可以给冒号后第二个数比较大的值，如100。范围的第二个数也可以写成负数，如<code>2:-2</code>表示<code>从第二个模块到倒数第2个模块</code></p>
<p>那么，如果主任务传递的列名，和子任务需要的列名不同时，该怎么处理？ 这就需要属性映射机制。配置子任务的<code>属性映射</code>时，可以用<code>a:b c:d</code>表示a列映射到b列，以此类推。</p>
<p>若不需要映射，则直接填写<code>a c</code>表示要将a列和c列传递给子任务，主任务不会也不需要将所有的参数都传递给子任务。因此，需要在子任务的转换器上，显式地设置原列名，并用空格分割。</p>
<p>Hawk3中还提供了图形化配置的界面，大大简化了配置难度，在任何子任务调用的模块里，都可以点击<code>配置</code>进入配置页面：</p>
<p><img alt="子任务的配置界面" src="https://images2018.cnblogs.com/blog/287060/201805/287060-20180506160707394-384705130.png" /></p>
<h2 id="3_5">3.注意事项</h2>
<p>下面是一些注意事项：</p>
<ul>
<li>主任务不会将所有的参数都传递给子任务，因为这可能并没有必要。因此，需要在子任务的转换器上，显式地设置原列名，并用空格分割，这样才能传递过去。</li>
<li>子任务还可以调用其他的子任务，形成树状的调用结构。当加载一个任务时，该任务依赖的子任务也会自动加载。对子任务的修改，也会传递到主任务上。目前，任务之间还不能自调用，也不能形成调用环。虽然函数确实是可以递归调用的，但对一个以generator为核心的流系统，递归可能并不需要。但如果真的支持，那一定会相当强大。</li>
<li>其实，在子任务层面，转换和执行除了是否有副作用外，最大的区别在于对主任务的影响，<code>子任务-转换</code>会将所有的结果返回给主任务，但<code>子任务-执行</code>则只需要输入参数，之后就是无头僵尸，将数据写到其他位置后，并不会影响主任务，在主任务中也看不到任何效果。这一段有些难以理解，但确实非常重要.</li>
</ul>
<h1 id="_39">动态页面抓取专题</h1>
<p>本文档讨论如何抓取动态页面，包括如何发现真实的数据请求，如何构造并解析请求返回的结果。</p>
<h2 id="1_6">1.什么是动态页面？</h2>
<p>动态瀑布流和ajax的页面，通常按需返回html和json.</p>
<p>老式网站在刷新时会返回页面的全部内容，但若只更新部分，即可大大节约带宽。该方式叫ajax，服务端传递xml或者json到浏览器，浏览器的js代码执行，并将数据渲染到页面上。 因此，获取数据的真实url，不一定显示在浏览器地址栏，而是隐藏在js调用中。本质上，javascript发起了新的隐藏http请求来获取数据，只要能模拟之，就能像真实浏览器一样获取所要数据。参考<a href="https://baike.baidu.com/item/ajax/8425?fr=aladdin">百度百科的介绍</a></p>
<h2 id="2_5">2.获取真实数据请求</h2>
<h3 id="21hawk">2.1.Hawk自动获取动态请求</h3>
<p>通过浏览器和抓包，可以获取这些隐藏请求，但需要对HTTP请求的原理比较熟悉，不适合于初学者。
Hawk简化了流程，采用自动嗅探的方式来进行。Hawk成为后端代理，会拦截和分析所有系统级Http请求，并将包含关键字的请求筛选出来 （基于fiddler）</p>
<p>当搜索字符时，若没有在当前页面中找到该关键字，Hawk会有提示，“是否启动动态嗅探？”此时Hawk会弹出浏览器并打开所在网页。您可将页面拖到包含关键字的位置，Hawk会自动记录和过滤包含关键字的真实请求， 检索完毕后，Hawk会自动回弹。</p>
<h3 id="22">2.2.如果无法自动嗅探?</h3>
<p>由于Hawk有拦截功能，会被浏览器认为不安全，有以下两种方案：
可以修改浏览器安全设置。    TODO:  增加浏览器的安全设置
//TODO</p>
<h3 id="23_2">2.3.注意事项</h3>
<ol>
<li>有时直接将url拷贝到Hawk，并使用手气不错时，也能获取到数据。这是因为很多网站对第一页和其他页分别作了不同的处理。第一页内容会跟着整体frame返回回来。但之后页面内容就通过ajax单独返回了。
有时针对第一页做了大量的XPath开发，却最后发现无法在其他页面使用，多半就是上面提到的问题（一脸懵逼）。因此经验上，建议翻到其他页面上再做请求。</li>
</ol>
<h3 id="24_1">2.4.手动获取真实请求</h3>
<p>即使嗅探失败也没有关系，如果你使用Chrome等浏览器，进入开发者工具（F12）：</p>
<p><img alt="image_1ao1q9le113a01mn4scu1q22g7mm.png-118.2kB" src="http://static.zybuluo.com/buptzym/lhxi16jt95iwhby6dlmpo9t8/image_1ao1q9le113a01mn4scu1q22g7mm.png" /></p>
<p>选择最上角的network卷展栏，之后刷新网页，chrome会列出所有的请求，一般最上面的就是真实请求：</p>
<p><img alt="image_1ao1qf5fo1geqsf13be1mpi1lia9.png-68.5kB" src="http://static.zybuluo.com/buptzym/5vmgbywxwlw71rqxjpk1jczt/image_1ao1qf5fo1geqsf13be1mpi1lia9.png" /></p>
<p>点击view source，将所有文本，拷贝到网页采集器，对应的<strong>高级设置-请求参数</strong>里即可。其实，Hawk做的也是类似的操作。</p>
<h2 id="3_6">3.请求构造</h2>
<h2 id="4_4">4.数据后处理</h2>
<p>拿到返回的真实数据后，除了用超级模式一步到位解析所需数据之外，还可以通过手动的方式，更灵活地取得所需数据。</p>
<h3 id="41json">4.1.Json处理</h3>
<p>Json是最为常见的数据传输格式，也是一棵树。里面包含键值对（字典）和数组，详细信息可以参考文档。</p>
<h4 id="1-json">步骤1： 将Json合法化</h4>
<p>有时候，网站传过来的json并不是非常合法的json，一些带回调的地址返回的数据，会是如下的形式:</p>
<pre><code>var datas=此处是json;
</code></pre>

<p>此时就需要通过字符首尾抽取，或正则表达式和字符串分割等方法，把真正合法的json提取出来。</p>
<h4 id="2_6">步骤2： 将字符串转换为文档</h4>
<p>上一步获取的结果，依然是个字符串，你需要将其转换为json。 拖入json转换器即可。常见的json有三种模式，我们依次讲解。</p>
<h5 id="1_7">类型1:</h5>
<p>数据可能位于'data'字段。此处，json转换器应当选择“不进行转换”，转换器本身就不进行任何操作，而是将该json作为整体传到新列里。</p>
<p>之后使用python转换器，脚本内容填写<code>value['data']</code>. value就是当前列所对应的内容，后面的部分是获取其data。 如果嵌套的更深，你可能需要 <code>value['data1']['data2']</code></p>
<pre><code>{
'total':12
'data':
[
{ 'key':'value'}
{ 'key':'value'}
]
}
</code></pre>

<h5 id="2_7">类型2:</h5>
<p>这种类型比较少见，是一种纯键值对的字典，我们通常想做的操作，是把内部的键值对都列出来，比如新添key1,key2两个列，内容是value。</p>
<p>方法很简单，json转换器选择"单文档"模式即可。不需要python转换器。</p>
<pre><code>{
'key1':'value'
'key2':'value'
}
</code></pre>

<h5 id="3_7">类型3:</h5>
<p>[
{ 'key':'value'}
{ 'key':'value'}
]</p>
<p>json选择器选择“文档列表”模式即可，不需要python转换器。</p>
<p>所以，看出来了么？json和python转换器的三种工作模式都是一个意思，当你要处理一个数组，就选择文档列表，一个字典，就选择单文档，如果还要取内部更深的信息，就选择<code>不进行转换</code>。</p>
<h3 id="42jsonhawk">4.2.json在Hawk的表示问题</h3>
<p>由于Hawk的可视化列表中，只能显示字符串和数字，而Json是一棵树，在Hawk中就很难显示.后期会考虑对这块做优化。</p>
<p>如果显示System.Object[]， 这表示是一个数组。
如果显示System.Generic.Dictionary... 表示为字典。 也就是文档。</p>
<p>这一块设计得确实非常糟糕，对于一般人来说理解起来太匪夷所思，也是我做得不够好的地方。。。希望能帮到大家。</p>
<h3 id="43pythonjson">4.3.用python转换器处理Json</h3>
<pre><code>
</code></pre>

<h2 id="5_2">5.案例.</h2>
<h3 id="51_1">5.1.嗅探</h3>
<p>我们以某政府网站的专利检索为例来说明如何使用: <code>http://www.pss-system.gov.cn/sipopublicsearch/patentsearch/showNavigationClassifyNum-showBasicClassifyNumPageByIPC.shtml?params=D7B3D1618C9AC685055FF6612F62529676324C8B6E7F92197ECA1C4E4212C394</code>
示例图如下：</p>
<p><img alt="image_1arbesmq01oucs8so2b6mq2fm9.png-72.7kB" src="http://static.zybuluo.com/buptzym/rklt3fzzuesx8dv6cfxakrip/image_1arbesmq01oucs8so2b6mq2fm9.png" /></p>
<p>不论你点什么样的下拉菜单，url是不变的。我们可以断定这是一个ajax页面。
现在的目标是，通过一个分类号，如<code>D01B1/00</code>，来获取它的中文含义和英文含义，也就是右边的内容：</p>
<p>我们启动Hawk，新建一个网页采集器，把刚才的那串url拷贝到网页采集器的地址栏里，发现获取的数据根本不包含这些中文含义。</p>
<p>怎么办呢？</p>
<p>你可以用嗅探，我们将<code>天然或人造的线或纤维</code>作为关键字，填写到网页采集器的<code>内容筛选</code>里:</p>
<p><img alt="image_1arbf4lfdqpp135k1s2uptkk4m9.png-13.9kB" src="http://static.zybuluo.com/buptzym/zp3w7vfutnzbzanvje1e1uvq/image_1arbf4lfdqpp135k1s2uptkk4m9.png" /></p>
<p>之后点击<code>开始</code>。然后在你的浏览器上点击下拉菜单，展开分类号。发现Hawk已经成功嗅探到了字段：</p>
<p><img alt="image_1arbf64jq15u811nfuei1bsknqcm.png-66.1kB" src="http://static.zybuluo.com/buptzym/1ltq5res3ct0gs0ucpwog2ru/image_1arbf64jq15u811nfuei1bsknqcm.png" /></p>
<p>此时，打开<code>请求属性</code>，就能看到真正请求的相关信息:</p>
<p><img alt="image_1arbf808c15gjq231kl61c5n1i1j13.png-95.9kB" src="http://static.zybuluo.com/buptzym/8zvakurfy2k1xp2nkr2g1yn1/image_1arbf808c15gjq231kl61c5n1i1j13.png" /></p>
<p>这是一次Post请求， (真实地址)url为:</p>
<blockquote>
<p>http://www.pss-system.gov.cn/sipopublicsearch/patentsearch/showNavigationClassifyNumAC!searchChildrenOfClassifyNum.do<code>post的内容是</code>classifyNum=D01<code>。有了这些，我们把这个采集器命名为</code>专利查询`，下一步就好办了。</p>
</blockquote>
<p>即使嗅探失败也没有关系，如果你使用Chrome等浏览器，进入开发者工具（F12）：</p>
<p><img alt="image_1ao1q9le113a01mn4scu1q22g7mm.png-118.2kB" src="http://static.zybuluo.com/buptzym/lhxi16jt95iwhby6dlmpo9t8/image_1ao1q9le113a01mn4scu1q22g7mm.png" /></p>
<p>选择最上角的network卷展栏，之后刷新网页，chrome会列出所有的请求，一般最上面的就是真实请求：</p>
<p><img alt="image_1ao1qf5fo1geqsf13be1mpi1lia9.png-68.5kB" src="http://static.zybuluo.com/buptzym/5vmgbywxwlw71rqxjpk1jczt/image_1ao1qf5fo1geqsf13be1mpi1lia9.png" /></p>
<p>点击view source，将所有文本，拷贝到网页采集器，对应的<strong>高级设置-请求参数</strong>里即可。其实，Hawk做的也是类似的操作。</p>
<h3 id="522">5.2.步骤2：</h3>
<p>此处我简单描述一下，你可以新建一个<code>数据清洗</code>,生成所有要查询的专利号的ID。这个相对容易。比如拖入<code>从文本生成</code>：</p>
<p><img alt="image_1arbfidlrfs95nanvr1d9df511g.png-16.8kB" src="http://static.zybuluo.com/buptzym/ewb47tdmo3ku50prz6s7v812/image_1arbfidlrfs95nanvr1d9df511g.png" /></p>
<p>再拖入<code>合并多列</code>，把这一串ID转换为要post的一列数据:</p>
<p><img alt="image_1arbfl2ska0f1tts1tns1q4t19e81t.png-29.5kB" src="http://static.zybuluo.com/buptzym/jyhis4psyps6y5a06jxks6f9/image_1arbfl2ska0f1tts1tns1q4t19e81t.png" /></p>
<p>再拖入<code>添加新列</code>，因为要让网页采集器访问那个真实数据的url,所以把上面提到的真实地址填进去：</p>
<p><img alt="image_1arbfo6b59qb5km1ore73rjrt2a.png-29.4kB" src="http://static.zybuluo.com/buptzym/f7xkx6azv5z0nhu8zdggj3ue/image_1arbfo6b59qb5km1ore73rjrt2a.png" /></p>
<p>见证奇迹的时刻到了，拖入<code>从爬虫转换</code>到刚才的url列，之后如下配置：</p>
<p><img alt="image_1arbfqoa217ggkmf1jhmiaa1ui12n.png-45.5kB" src="http://static.zybuluo.com/buptzym/m0m013nyrr2zlyuckfv0obwu/image_1arbfqoa217ggkmf1jhmiaa1ui12n.png" /></p>
<p>由于post数据要从post列读入，所以用方括号括起来，像这样<code>[post]</code>.</p>
<p>出现了这样的结果：</p>
<p><img alt="image_1arbfsnt1p6oh18vmt8l91dmt34.png-20.8kB" src="http://static.zybuluo.com/buptzym/cew1tojr4n8kipkrgy2nwltg/image_1arbfsnt1p6oh18vmt8l91dmt34.png" /></p>
<p>这是个Json,因此我们拖入<code>转换为json</code>到content列：并将生成模式改为<code>单文档</code>，因为这只是一个字典，而不是字典数组:</p>
<p><img alt="image_1arbg0o161t0a1nml10ho1jmu1j9l3h.png-9.5kB" src="http://static.zybuluo.com/buptzym/98revkg9c8o6r93xa6hz23jc/image_1arbg0o161t0a1nml10ho1jmu1j9l3h.png" /></p>
<p>你会发现只有一列有值:</p>
<p><img alt="image_1arbg20op1dvqvtqfeon531ct93u.png-5kB" src="http://static.zybuluo.com/buptzym/k067q3ipf1n2lmjonqvz5vy0/image_1arbg20op1dvqvtqfeon531ct93u.png" /></p>
<p>是个数组。那么，再拖入<code>python转换器</code>，生成模式配置为<code>文档列表</code>:
你要的数据就都有了：</p>
<p><img alt="image_1arbg3qee1if195k1pnl1an71uaj4b.png-29.4kB" src="http://static.zybuluo.com/buptzym/qd1245knqvcg4e55910ovgbl/image_1arbg3qee1if195k1pnl1an71uaj4b.png" /></p>
<p>点评：这种请求，虽然可以用Hawk来配置，不过还是建议使用python，能获取更大的灵活性</p>
<h1 id="_40">增量/自动化/定时抓取专题</h1>
<p>Hawk虽然是图形化软件，但依然支持命令行和自动化抓取，本专题讨论如何增量，和自动化定时抓取。</p>
<h2 id="1_8">1.增量抓取</h2>
<p>增量抓取比较困难，各网站皆有不同，此处我们提供一些技巧。</p>
<p>一种类型是新闻型的，按照时间排列，并更新最新的新闻，最朴素的思路是记录上一次抓取的最后位置。然后在新的一轮抓取中，不停地向前获取，直到发现上一次抓取后中断。</p>
<p>此处需要两个核心技术点：</p>
<h3 id="11_3">1.1.保存上一次存储的关键字</h3>
<p>首先找到代表数据特征的列（如ID，标题等），能唯一标识该数据。如果找不到唯一的列，可通过<code>合并多列</code>来组合。</p>
<p>在这一列拖入<code>更新到配置</code> , 输入要更新的配置的名称column，则在执行时，该模块每经过一行数据，就会自动更新该列的值到全局配置(TODO：路径)中。配合软件的自动保存机制，该值会随时写入配置文件中。</p>
<h3 id="12_1">1.2.下次执行时定位到中断点</h3>
<p>在任务配置时，添加<code>正则过滤</code>，正则项的值填写为<code>{column}</code>，代表从配置中读取该值。</p>
<h1 id="_41">编译和扩展开发</h1>
<hr />
<p>Hawk是开源项目，因此任何人都可以为其贡献代码。作者也非常欢迎使用者能够扩展出更有用的插件。</p>
<blockquote>
<p>现在这样的同学屈指可数，看来我们离共产主义社会还有点远
看到这里，你肯定接触过沙漠君写的代码，不要吐槽，那是他研究生单身时写的，愤世嫉俗，只要能用就行。</p>
</blockquote>
<h2 id="1_9">1.编译</h2>
<p>编译需要Visual Stuido，版本建议使用2015, 2010及以上没有经过测试，但应该可以编译。
需要安装.Net Framework 4.5 和.NET Framework 4.0
没有其他依赖项。</p>
<p>出现编译问题时，请查看<code>7. 常见问题</code>中的<code>编译问题</code></p>
<h2 id="2_8">2.代码结构</h2>
<p>Hawk采用插件式结构，所有的组件都是可分离的。插件系统是自行设计的，非常类似于MEF框架。使用WPF技术，MVVM结构，界面和逻辑分离。</p>
<p>工程文件介绍如下：</p>
<ul>
<li>Hawk.Core 底层基础类库</li>
<li>Hawk.ETL  数据清洗和爬虫插件库</li>
<li>Hawk.ETL.Controls 界面库</li>
<li>HawkScheduler 命令行调度器</li>
<li>HawK.exe 可执行程序和插件容器</li>
</ul>
<p>核心的需要修改的代码，都位于Hawk.ETL和Hawk.Core中。</p>
<h2 id="3_8">3.实现新的连接器</h2>
<p>以实现MySQL支持为例，在Hawk.Core.Connectors目录中，新建MySQLConnector.cs文件，创建对应的类，从DBConnectorBase继承。
在类上添加attribute，结构如下：
[XFrmWork("MySQLConnector")]
public class MySQLConnector
{
//implement interface IDataBaseConnector
}</p>
<h2 id="4_5">4.实现新的子模块组件</h2>
<p>如果你想开发新的组件，完全可以参考已有的代码。但一些特别简单的功能，不建议再开发新的插件，而是直接使用Python转换器即可。</p>
<p>你可以创建一个.NET工程，之后引用Hawk.Core.dll即可。不论是界面控件，转换器，过滤器还是执行器，都可以从已有的基类继承。</p>
<p>生成对应的dll文件后，可以将其拷贝到Hawk的根目录下，并在PluginLoadLogic.xml配置文件中，修改PluginFileName配置节，将该文件的dll文件名粘贴进去。这样Hawk在启动时，就会自动检索该dll中的所有插件。</p>
<h2 id="5_3">5.备注</h2>
<p>这方面如果有任何问题，欢迎联系作者，不过我打赌，因为想新开发组件而找我的朋友，一年最多三个</p>
<h1 id="_42">常见问题</h1>
<h2 id="1_10">1.网页采集器</h2>
<h3 id="11_4">1.1.自动嗅探失败</h3>
<p>网页采集器具备自动嗅探功能，本质上是替换掉了底层的代理。因此，所有的请求都通过Hawk内部，自然就能根据需求筛选出所需的请求。</p>
<p>但有些系统中安装了类似360等工具，会拒绝这类操作。导致嗅探失败。目前原因还没有找到。一些网站做了加密，因此即使输入检索字段，内容也不一定能检索得到。</p>
<h3 id="12_2">1.2.被封锁问题</h3>
<p>被封锁有几个原因：</p>
<h4 id="_43">被网站识别为非浏览器</h4>
<p>出现这种情况的原因是请求参数为空，没有模拟为浏览器(user-agent)，如大众点评只防此类爬虫。</p>
<p>最新改进的版本中，Hawk默认请求参数已经加入了user-agent,因此能解决掉一大部分初级问题。</p>
<h4 id="_44">频繁访问</h4>
<p>这取决于网站如何认定是同一个使用者。</p>
<ul>
<li>有的网站认为同一台机器的不同浏览器也是不同的用户。</li>
<li>有的网站认为只要IP相同，则使用者一定相同</li>
</ul>
<p>对前一种情况，可以随机在一大批User-agent列表中挑选一条，模拟为不同的浏览器，就能大大降低被PB的概率。典型的例子如豆瓣。</p>
<p>对后一种情况，很不幸需要使用真正的代理，或使用分布式方案。免费代理通常都不稳定，而付费代理则需要付费，很少有人愿意为了爬虫付钱（一脸黑线）。</p>
<p>因此，Hawk会考虑提供第一种情况的解决方案，但不会自动开启，而是在用户需要的时候手工开启。</p>
<p>而自动代理切换，目前Hawk不会提供支持。原因更多考虑的是技术之外的因素。</p>
<h3 id="13_1">1.3.抓取动态请求</h3>
<p>这是被问的最多的问题。加载一个完整的网页，可能需要几十次请求，不少请求是ajax和动态的，而不少数据都保存在这些请求之中。</p>
<p>最早版本的Hawk内置了一个IE内核的浏览器，后来取消了这个功能。原因很简单：</p>
<ul>
<li>内置浏览器，导致过分复杂</li>
<li>无法多线程抓取</li>
<li>大量无用的请求，导致抓取速度变慢</li>
<li>即使内置浏览器，也不见得能抓取所有动态请求</li>
</ul>
<p>因此，纯HttpClient能够精确并只抓取你想要的内容，只要正确构造它即可。
如何使用？你需要配置一个<strong>网页采集器</strong>。
将它的行为，模拟到和浏览器一致。</p>
<p>第一种方法，查看浏览器的请求，参考  ，将请求详情复制过来，注意选择GET和POST。</p>
<p>之后，将嗅探到的地址拷贝到网页采集器的URL输入框中，查看是否能正确获取内容。
如果是POST请求，就更复杂一些。在数据清洗模块中，网页采集器拖入的列需要是对应的URL，你还需要构造出每次访问的post数据，单独作为一列。在网页采集器中如下配置：</p>
<p>![image_1ao1rk5bb1am4pl31j2l1a0l1otpm.png-18.7kB][3]
注意列名需要用方括号括起来，否则每次POST数据都会是所填的数据。</p>
<h3 id="14_1">1.4.验证码问题</h3>
<p>这也是问的非常多的问题，很不幸，<strong>不支持</strong>。验证码各种各样，简单到纯数字，复杂到12306，图像转文本涉及到太多的不确定因素。</p>
<p>解决方案也有，一些网站提供识别验证码的接口API，因此你可以让Hawk去模拟网站的API，将图片地址传递过去，API会自动返回验证码。坏消息是这个一般需要收费。
不过，能配置Hawk去做这样的请求的人，一定也能够写Python了，算了，他还是去写Python吧，别跳Hawk这个坑了。</p>
<h3 id="15path">1.5.Path搜索相关问题</h3>
<p>网页采集器中，填写关键字，却发现无法找到XPath。
可能的原因：</p>
<h4 id="_45">网页是动态网页</h4>
<p>因此本链接不包含该关键字，建议考虑使用嗅探方案</p>
<h4 id="_46">关键字太长</h4>
<p>是文本中包含不可见字符时经常出现。例如 340[制表符]万，但用户可能会直接输入340万。Hawk搜索是按照严格字符串匹配的，就会匹配不成功，因此输入短一些，如340</p>
<h4 id="chromexpath">和 Chrome等浏览器得到的XPath不同</h4>
<p>一方面，XPath的表示方法有很多种，这和正则类似。可能看起来不一样的XPath指代的都是同一个节点。
另一方面，Chrome会执行js代码，而js可能会改变网页的结构，因此XPath也就对应地发生变化了。这会通常会导致从Chrome拷贝出来的XPath在Hawk中不能使用。
Hawk未来不会考虑支持加入执行js代码的功能，因此，如果搜索XPath，还请以Hawk得到的结果为准。多搜多看，通常就能建立感觉。</p>
<h3 id="16">1.6.手气不错的问题</h3>
<p>很多人使用手气不错会失败。这是因为：</p>
<h4 id="_47">不是所有的网页都支持直接点击【手气不错】</h4>
<p>手气不错需要特定的网页结构（列表），如果整个网页没有显著的列表节点，则搜索失败，此时就会提示 手气不错失败。</p>
<h4 id="_48">手气不错会自动规约父节点</h4>
<p>使用手气不错后，嗅探器会找到列表节点的父节点，以及挂载在父节点上的多个子节点，从而形成一个树状结构:</p>
<ul>
<li>父节点(/html/div[2]/div[3]/div[4])</li>
<li>子节点1(/a[1])</li>
<li>子节点2(/a[2]/@href)</li>
<li>其他省略 有时候，父节点的xpath是不稳定的，举个例子，北京上海的二手房页面，上海会在列表上面增加一个广告banner，从而真正的父节点就会发生变化。为了应对这种变化，通常的做法是手工修改【父节点XPath】，继续举例子，父节点的id为<code>house_list</code>，且在网页中全局唯一，你就可以使用另外一种父节点表示法<code>//*[@id='house_list']</code>（写法可以参考其他XPath教程），而子节点表达式不变。
Hawk在【手气不错】得到【确定】后，会询问是否提取父节点XPath，此时Hawk会自动提取【父节点XPath】到属性对话框中，从而方便修改。</li>
</ul>
<h3 id="17">1.7.获得的页面与浏览器上不一样？</h3>
<p>这非常常见，考虑到速度，Hawk不会动态执行js请求。而浏览器会大量执行js加载图片等，获得的源码可能有所不同，更不用说搜索得到的XPath了。但这样能获得百倍于浏览器的执行速度，因此这个缺点是值得的。</p>
<p>那如何抓取动态页面呢？对于这种情况，参考<a href="../网页采集器/#2.动态嗅探">动态嗅探</a>章节。</p>
<p>即使是同样的页面，用Hawk得到的XPATH与浏览器不一致，为什么呢？</p>
<p>一方面，XPath的表示方法有很多种，这和正则类似。可能看起来不一样的XPath指代的都是同一个节点。另一方面，Chrome会执行js代码，而js可能会改变网页的结构，因此XPath也就对应地发生变化了。这有可能会导致从Chrome拷贝出来的XPath在Hawk中不能使用。</p>
<p>Hawk未来不会考虑支持加入执行js代码的功能，因此，<strong>如果搜索XPath，还请以Hawk得到的结果为准。多搜多看，通常就能建立感觉</strong>。</p>
<h3 id="18">1.8.一个网站要设置好多个页面，配置太繁琐！</h3>
<p>可在<code>系统状态视图</code>中，将网页采集器拖到下面的<code>复制</code>图标上，即可复制多个采集器。这样可一定程度上简化操作。</p>
<p>当一组采集器需要同一组请求参数时，可设置<code>共享源</code>自动同步，参考<code>3.2采集器高级用法</code>的最后一节。</p>
<h2 id="2_9">2.数据清洗</h2>
<h3 id="21_1">2.1.拖入<code>从爬虫转换</code>后没有任何数据。</h3>
<p><code>从爬虫转换</code>实际上搭建了采集器与数据清洗的桥梁，它要选择对应的网页采集器才行，</p>
<h3 id="22_1">2.2.拖入<code>从爬虫转换</code>后，数据有了，但之前的列消失了</h3>
<p>参考 <code>4.3转换器</code> 中<code>UDAF的特别说明</code>.</p>
<h2 id="3_9">3.编译与运行问题</h2>
<p>虽然在GitHub上是最新的代码，最新代码是可以成功编译的。但不能保证用户是否clone的是早期版本的代码，因此此处罗列可能的编译错误。</p>
<h3 id="31_5">3.1.编译问题</h3>
<ol>
<li>
<p>从GitHub上拉回来的代码，默认启动路径是<code>Hawk.Core</code>，这导致编译成功，但运行时提示“无法直接启动带有类库输出类型的项目”： 将Hawk设置为解决方案的启动项目，参考这里：https://jingyan.baidu.com/article/4e5b3e1934c2fc91901e2426.html</p>
</li>
<li>
<p>因为工程<code>Hawk.csproj</code>包含的两个图片文件不存在导致，在这些文件图标上点击右键，选择'排除出项目'，即可正常编译。</p>
</li>
<li>
<p>找不到项目<code>System.Windows.???.WPFPropertyGrid.csproj</code>项目，有两种方法，一种是从作者的GitHub上clone对应的项目，并添加项目引用，另外一种做法是，删除项目引用，添加外部dll引用，所有的外部dll，都能在Include文件夹中找到。</p>
</li>
<li>
<p>大量的库找不到，几百个报错：</p>
</li>
</ol>
<p>Hawk编译用了不少第三方类库，因此需要配置nuget，它是微软技术栈的pip，能自动安装所需的依赖，配置可参考这里：</p>
<blockquote>
<p>https://docs.nuget.org/</p>
</blockquote>
<h3 id="32_5">3.2.启动后软件只有外边框，没有其他任何显示</h3>
<p>老版本的Hawk(小于1.2)在Win7和Win8下的兼容性不佳，请升级最新版本的Hawk.</p>
<h3 id="33_3">3.3.不小心关掉了某个侧边栏</h3>
<p>Hawk采用了Visual Stuido风格的Dock系统，所有的布局都可以调节大小，设定位置，常见的错误是，不小心关闭了某个面板。如何恢复呢？ 对于任务的窗口，双击任务应该就能恢复，如果是日志边栏，不好意思，恢复不了，重启软件吧。</p>
<h2 id="4_6">4.宏观问题</h2>
<p>和具体使用无关，主要涉及对一些吐槽的回答</p>
<h3 id="41windows">4.1.为什么只支持Windows？</h3>
<p>笔者曾是微软技术栈的粉丝，因此C#,WPF成了设计首选，如今虽然技术栈大大扩展，但用Js或其他语言重写成本太高，因此依然只提供Windows版本。 虽然笔者平时也只用MAC了...</p>
<h3 id="42">4.2.为什么不提供更强的代理？</h3>
<p>爬虫是一种灰色的应用，虽然作为Hawk的设计者，但我依然不得不这么说。</p>
<p>各大网站都在收集和整理数据上花费了大量的精力，因此抓取的数据应当仅仅作为科学研究使用。作者对Hawk的使用者的行为，不承担任何连带责任。</p>
<p>建议您理性使用爬虫，在不影响网站正常运营的情况下抓取数据。Hawk的好处是，较大地降低了爬虫的开发成本，能让普通用户也能使用。在这一理念下，我们仅仅提供最为实用的功能，而更多高级的功能则不会提供。比如代理切换和验证码识别。</p>
<p>在并行模式下，仅提供单机并行，而分布式并行也不会提供。尽管如此，我们还是会简单讨论如何验证码识别,代理和并行的问题。</p>
<p>代理实现并不复杂，在代码层面上只需要几行代码。但基于之前提过的原因，开源版本不提供代理的支持。</p>
<h3 id="43_1">4.3.验证码识别？</h3>
<p>验证码识别确实有难度，因为各大网站都不相同，简单的如普通四位数字验证码，难的如12306的变态验证码。因此提供通用的识别几乎是不可能的。</p>
<p>如果您愿意付费，并使用第三方的图形验证码服务，则可以将其配置为一个网页采集器，再调用之。</p>
<h3 id="44mongodbsqlite">4.4.为什么只支持MongoDB和Sqlite?</h3>
<p>Hawk在设计之初，就是以弱schema风格定义的。没有严格的列名和列属性。用C#这样的静态强类型语言编写Hawk，其实并不方便。但弱schema让Hawk变得更灵活更强大。</p>
<p>因此，Hawk虽然之前支持各种数据库连接器，而目前只支持MongoDB这样的文档型数据库。之所以不支持传统SQL，是因为获取的数据可能并不满足这些SQL数据库的约束：如列的顺序，列的字段类型，是否为空...很容易导致插入失败。使用Hawk的一般不是程序员，我不想给普通人挖这样的坑。</p>
<p>当然，从各类SQL数据库中读入数据也是可以的，但既然没有提供写入，我们也就索性不提供读入了。需要的话，你可以自己扩展其他数据库连接器。</p>
<p>不过，简单的才是最好的，以作者的经验，使用MongoDB这样的数据库来应对爬虫已经足够了：不需事先建表，高性能，低成本，低维护。我们也不可能一次性就把数据规约成你想要的形式，之后完全可以用其他工具和代码，再将MongoDB的数据导出来，写入到目标数据库。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="./" class="btn btn-neutral" title="16.Hawk_Total_Doc"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="./" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
